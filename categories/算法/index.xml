<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on fyzn12的博客</title>
    <link>https://fyzn12.github.io/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on fyzn12的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 25 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://fyzn12.github.io/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>求两个有序数组的中位数</title>
      <link>https://fyzn12.github.io/post/algorithm/%E5%AF%BB%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E5%AF%BB%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>  给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
 leetcode给出从时间复杂度和空间复杂度最优解分析 方法一：二分查找 给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：
使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。 不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数 组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 000 的位置，每次将指向较小 值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数 的位置。 假设两个有序数组的长度分别为 m 和 n，上述两种思路的复杂度如何？
第一种思路的时间复杂度是 O(m+n)，空间复杂度是 O(m+n)。第二种思路虽然可以将空间复杂度降到 O(1)，但是时间复杂度仍是 O(m+n)。题目要求时间复杂度是 O(log⁡(m+n))，因此上述两种思路都不满足题目要求的时间复杂度。
如何把时间复杂度降低到 O(log⁡(m+n)) 呢？如果对时间复杂度的要求有 log，通常都需要用到二分查找，这道题也可以通过二分查找实现。
根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1。
注意：以上分析思路来自于leetcode官方阶梯思路 </description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://fyzn12.github.io/post/algorithm/tree/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/tree/</guid>
      <description>二叉树的简单介绍
 二叉树的定义 二叉树是(n&amp;gt;=0)个节点的有限集合，他或者(n==0)时为空树，或者（n&amp;gt;0时）由一个根节点及两颗互不相交的分别称为跟的左子树和右子树的二叉树组成。
2 二叉树的遍历 2.1 前序遍历 递归实现的算法分析 前序遍历二叉树的递归定义为：若二叉树为空树则遍历结束，否则
1. 访问根节点
2. 前序遍历根节点的左子树
3. 前序遍历根节点的右子树
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 算法实现 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
public class Tree { private class Bitree&amp;lt;T&amp;gt;{ T data; Bitree lchild; Bitree rchild; public Bitree(T data,Bitree lchild,Bitree rchild){ this.data = data; this.lchild = lchild; this.rchild = rchild; } } private void preorder(Bitree bt){ //设置递归终止条件  if (bt==null){ return; } //输出 跟节点  System.out.println(bt.data); //前序遍历左子树  preorder(bt.lchild); //前序遍历右子树  preorder(bt.rchild); } }  2.</description>
    </item>
    
    <item>
      <title>哈希检索</title>
      <link>https://fyzn12.github.io/post/algorithm/hashtable/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/hashtable/</guid>
      <description>哈希检索算法的深度学习
 1 相关概念的理解 1.1 哈希检索  概念： 哈希检索技术的初衷是组织理想状态的检索表。检索表的理想状态是：把记录的关键字值与记录在检索表中的存储位置建立起某种一对一的关系，这种一对一的关系可以用关键字的一个函数h(key)来表示，这样不必进行关键字与给定值的比较，而是直接依据给定的关键字值来直接计算得到记录在检索表中的存储地址。 哈希函数（散列函数、杂凑函数）：反应关键字与存储位置一对一关系的函数h(key) 哈希检索技术必须解决的两个问题
（1）如何选择一个计算简单且地址冲突尽可能少的哈希函数；
（2）在出现地址冲突时采用什么办法解决冲突
  1.2 哈希函数的构建方法  直接定址法：h(key) = a*key + b 数字分析法：提前知道关键字值的集合，分析关键字集合的分布情况，确定散列函数； 平方取中法：先求出关键字的平方，然后取中间几位作为哈希地址；
 折叠法 除留余数法：h(key) = key % p 余取整法 随机数法：h(key) = random(key)
  2 地址冲突的消解策略 2.1 开放地址法 把哈希表中的空位置向处理地址冲突开放，具体的做法是，当发生地址冲突时，从发生地址冲突的那个位置开始，使用某种方法在哈希表中形成一个探查序列。
2.1.1 线性探查法  线性探查法是开放地址法消除地址冲突的一种最简单的探查方法。他把表长为m的哈希表看成是循环表，若发生地址冲突的位置地址为d，则依次探查d+1, d+2, &amp;hellip;,直到找到一个空闲位置为止。
 公式：（地址）d = (h(key)+i)%m ， 其中i=1,2,&amp;hellip;,m-1
 缺点：线性探查法易造成堆积现象。
  2.1.2 平方探查法  平方探查法也称为二次探查法。在发生地址冲突时，依次探查位置d+i，其中i取 1^2,-1^2,2^2,-2^2,&amp;hellip;, 公式：d = (h(key)+i^2)%m,d = (h(key)-i^2)%m 和中心扩展法相同，以地址冲突的位置，分别向两边去寻找空地址。</description>
    </item>
    
    <item>
      <title>LinkedList以及栈的深度理解</title>
      <link>https://fyzn12.github.io/post/algorithm/linkedlist/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/linkedlist/</guid>
      <description>算法背景:给定一个只包括 &amp;lsquo;(&amp;lsquo;，&amp;rsquo;)&amp;lsquo;，&amp;rsquo;{&amp;lsquo;，&amp;rsquo;}&amp;lsquo;，&amp;rsquo;[&amp;lsquo;，&amp;rsquo;]&amp;rsquo; 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。
 1 首先了解LinkedList的底层实现 1.1 LinkedList的底层实现 LinkedList的底层是基于 双向链表 实现，使用Node存储链表节点信息。源码如下 private static class Node&amp;lt;E&amp;gt; { E item; Node&amp;lt;E&amp;gt; next; Node&amp;lt;E&amp;gt; prev; } 每个链表都存储了first和last指针； transient Node&amp;lt;E&amp;gt; first; transient Node&amp;lt;E&amp;gt; last;   2 设计算法，实现上面的需求 2.1 算法的实现 public static boolean isValid(String s) { int n = s.length(); if (n % 2 == 1) { return false; } Map&amp;lt;Character, Character&amp;gt; pairs = new HashMap&amp;lt;Character, Character&amp;gt;() {{ put(&amp;#39;)&amp;#39;, &amp;#39;(&amp;#39;); put(&amp;#39;]&amp;#39;, &amp;#39;[&amp;#39;); put(&amp;#39;}&amp;#39;, &amp;#39;{&amp;#39;); }}; Deque&amp;lt;Character&amp;gt; stack = new LinkedList&amp;lt;Character&amp;gt;(); for (int i = 0; i &amp;lt; n; i++) { char ch = s.</description>
    </item>
    
    <item>
      <title>几种结构</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>  数据结构的分析
 1 队列 队列采用先进先出策略的集合类型，如图所示
1.1 队列的入队演示 如图将 89 添加到队列中，采用的是 ： 在队列队尾添加，整个事件时间复杂度为O(1)  1.2 队列的出队演示 当队列收到出队的命令后，会将指针指向head，从而移除head的值，原先head值指向的下一个值变为head，整个事件时间复杂度为 O(1)  注意：java中还有先进先出队列，策略和基本队列相反，和下面的栈的策略相同 1.3 队列的总结，队列是采用先进先出的策略，添加元素时是在队尾添加，出队时是在队头移除或出队 2 链表 2.1 链表插入策略的演示 2.1.1 头插  2.1.2 尾插  2.1.3 中间任意部位插入 任意部位的插入首先要指定一个插入点，在插入过程中会先遍历插入点前面的元素，找到插入点元素 之后在修改插入点元素的指针，让其指向新增元素   3 栈 栈（stack）是操作受限的线性表，限定元素的插入和删除运算只能在表的一端进行，通常把进行插入删除的一端称作栈顶（top） 另一端称为栈底（bottom）  3.1 栈的五种运算  置空栈setnull（s）：将栈s设置成空栈，即不管栈的原来状态如何一律置为空栈；
 判断栈是否为空empty(s):返回一个布尔值，当栈为空时返回1，否则返回返回0；
 进栈push(s,x):把元素x压入栈s中，成为新的栈顶元素；
 出栈pop(s):该操作从栈顶弹出栈顶元素并返回，栈为空时返回NULL；
 读栈顶元素gettop(s):返回栈顶元素，该操作栈的状态不变；   栈与队列的总结 栈可以形象的比喻为一个瓶子，先进的元素只能从瓶口进，然后往瓶底走，出的时候也只能从瓶口出，而后面进的元素往往先出 队列可以看成一条管道，该管道从bottom入，top出 </description>
    </item>
    
    <item>
      <title>常见算法篇</title>
      <link>https://fyzn12.github.io/post/algorithm/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
      <description>常见算法总结篇 递归算法 递归算法有一下几个特点 * 递归算法必须设定循环终止条件，称为递归出口 * 方法里调用自身 如下面两个例子： 1. 一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。 例：n=1237 函数设定如下： //编写递归函数 private static void getNUm(int n){ //设置递归终止条件 System.out.printl(n); if（n&amp;lt;=5000）{ //调用自身 getNum(n*2); System.out.printl(n); } } 2. 第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？ 程序设定如下 //n代表传入的人的数量 private static int getAge(int n){ //设定递归终止条件 if（n==1） return 10; //调用自身并返回； return getAge(n-1)+2; } 排序算法  快速排序算法 排序步骤总结如下：
* 从数组中挑出一个元素，称为“基准”（pivot）； * 重新排序数组，所有元素比基准值小的摆放在基准前面，所有元素比基准大的摆放在基准的后面 （相同可以任意放一边）。这个分割之后，该基准就是他的最后的位置，这个称为“分割”操作 * 递归地把小于基准值元素的子数组和大于基准元素的子数组排序。 下面看一个列子： 请用快速排序排序下面的数组内的数字：String[] strVoid=new String[]{&amp;#34;11&amp;#34;,&amp;#34;66&amp;#34;,&amp;#34;22&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;55&amp;#34;,&amp;#34;22&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;32&amp;#34;}; 代码设计如下：严格按照上面三个步骤设计 //三个参数，排序的数组，排序左基点，排序右基点 private static void quickSort(String[] strViod,int left,int right){ //先判断左右指针是否越界 if (left&amp;gt;right){ returen; } //定义基准位置，左右移动时的指针以及中间变量 String standard,tmp; //步骤一：确定基准位置（可以随意） standard = strViod[left]; int i,j; i = left; j = right; //步骤二：初步与基准值比较，确认基准值的左右集合 while(i&amp;lt;j){ //首先进行基准值右侧值的判断,这里建议将String转为int进行判断，别用compareTo进行判断 while(Integer.</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://fyzn12.github.io/post/algorithm/selectionsorted/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/selectionsorted/</guid>
      <description>排序算法的简单介绍
 1 选择排序 1.1 选择排序的理解 选择排序（Selection sort）是一种简单直观的排序算法。 它的工作原理是： 第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置， 然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序 的数据元素的个数为零。选择排序是不稳定的排序方法。  1.2 选择排序的实现 /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/14 18:41 * @description:选择排序 */ public class SelectionSort { public static void sort(Comparable[] a) { int N = a.length; //将a[]按升序排序  for (int i = 0; i &amp;lt; N; i++) { int min = i; for (int j = i+1;j&amp;lt;N;j++){ if (less(a[j],a[min])){ min = j; } } exch(a,i,min); } } private static boolean less(Comparable v,Comparable w){ return v.</description>
    </item>
    
  </channel>
</rss>