<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fyzn12个人博客</title>
    <link>https://fyzn12.github.io/</link>
    <description>Recent content on fyzn12个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 11 Jun 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://fyzn12.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>java基础篇</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/</guid>
      <description>java中保证多线程的运行安全  原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操着（atomic，synchronied）;
 可见性：一个线程对主内存的修改可以及时的被其他线程看到（synchronied，volatile）； 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂论无序（happens-before原则）  session和cookie的区别  由于http协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是session，如购物车，在服务端需要记录该用户的状态。在服务端保存session的方式有很多，比如内存、数据库、文件。集群的时候也要考虑session的转移，一般会有专门的session服务器集群，（使用缓存服务器Memcached）。 服务端如何识别特定的用户：每次Http请求时，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪，第一次创建session时，服务端会在Http协议中告诉客户端，需要在Cookie里面记录一个session ID，以后每次请求把这个会话ID发送到服务器，如果客户端浏览器禁用了Cookie，一般情况下会使用URl重写的技术来进行会话跟踪，即每次HTTP交互时，URL后面都会附加上一个sid=xxxx这样的参数，服务端据此来识别用户。 Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。   session的工作原理 session是存在服务器上的类似于一个散列表格。类似于一个大号的map，里面存储的是用户的session ID，用户向服务器发送请求的时候会带上这个session ID，这时就可以从中取出对应的值。
struts和springMVC的区别  拦截机制不同
 struts是类拦截。每次请求都会创建一个action。 springMVC是方法级别的拦截。  底层框架不同
 struts2采用Filter实现，SpringMVC采用servlet实现。Filter在容器启动后即初始化；服务器停止后坠毁，晚于servlet。servlet是在调用的时候初始化，先于Filter调用，服务停止后销毁。
  配置方面
spring MVC 和spring是无缝的。从这个项目的管理和安全上也比struts2高。
  避免sql注入  使用preparedstatement 使用正则表达式过滤传入的参数 字符串过滤 jsp调用该函数检查是否包含非法字符 jsp页面判断代码
  什么是XSS攻击 XSS攻击又称CSS，其原理是攻击者向有XSS漏洞的网站中输入恶意的HTML代码，当用户浏览该网站时，这段html代码就会执行，从而达到攻击的目的。XSS攻击类似于SQL注入的攻击，SQL注入攻击中以SQL语句走位用户输入，从而达到查询/修改/删除数据，而在xss攻击中通过恶意脚本，实现对用户浏览器的控制，获取用户的一些信息。XSS是web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式。
XSS防范的总体思路是：对输入（和URL参数）进行过滤，对输出进行编码。 什么是CSRF攻击 CSRF也称为one-click attack或者session riding，中文全称叫&amp;rdquo;跨站请求伪造&amp;rdquo;。一般来说攻击者通过伪造用户浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接受并以为是用户的真实操着而去执行用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。
如何避免CSRF攻击  验证HTTP Referer字段：
HTTP头中的Referer字段记录了该HTTP请求的来源地址。通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施CSRF攻击，他一般只能在他自己 的网站构造请求。因此，可以通过验证Referer值来防御CSRF攻击。 使用验证码 关键操作页面上加上验证码，后台接收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。 在请求地址中添加token并验证。 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?</description>
    </item>
    
    <item>
      <title>常见算法篇</title>
      <link>https://fyzn12.github.io/post/algorithm/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
      <description>常见算法总结篇 递归算法  递归算法有一下几个特点 * 递归算法必须设定循环终止条件，称为递归出口 * 方法里调用自身 如下面两个例子： 1. 一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。 例：n=1237 函数设定如下： //编写递归函数 private static void getNUm(int n){ //设置递归终止条件 System.out.printl(n); if（n&amp;lt;=5000）{ //调用自身 getNum(n*2); System.out.printl(n); } } 2. 第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？ 程序设定如下 //n代表传入的人的数量 private static int getAge(int n){ //设定递归终止条件 if（n==1） return 10; //调用自身并返回； return getAge(n-1)+2; }  排序算法  快速排序算法 排序步骤总结如下：
* 从数组中挑出一个元素，称为“基准”（pivot）； * 重新排序数组，所有元素比基准值小的摆放在基准前面，所有元素比基准大的摆放在基准的后面 （相同可以任意放一边）。这个分割之后，该基准就是他的最后的位置，这个称为“分割”操作 * 递归地把小于基准值元素的子数组和大于基准元素的子数组排序。 下面看一个列子： 请用快速排序排序下面的数组内的数字：String[] strVoid=new String[]{&amp;quot;11&amp;quot;,&amp;quot;66&amp;quot;,&amp;quot;22&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;55&amp;quot;,&amp;quot;22&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;32&amp;quot;}; 代码设计如下：严格按照上面三个步骤设计 //三个参数，排序的数组，排序左基点，排序右基点 private static void quickSort(String[] strViod,int left,int right){ //定义在排序过程中的左右基点 int i = left; int j = right; //定义左右替换值时的替换参数 String temValue; //步骤一：获取基准 String middle = strViod[(i+j)/2]; //步骤二：找出比基准大和小的值，并摆放其左右； do{ //找到比基准小的值 while(strViod[i].</description>
    </item>
    
    <item>
      <title>ssm随学札记</title>
      <link>https://fyzn12.github.io/post/ssm/ssm%E9%9A%8F%E5%AD%A6%E6%9C%AD%E8%AE%B0/</link>
      <pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/ssm/ssm%E9%9A%8F%E5%AD%A6%E6%9C%AD%E8%AE%B0/</guid>
      <description>使用在使用ObjectMapper将json转对象，调用mapper.readValue(jsonStr, XwjUser.class)时，报如下错：
 java.lang.NullPointerException at com.fasterxml.jackson.core.JsonFactory.createParser(JsonFactory.java:889) at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3004) at com.express.utils.JsonUtils.jsonToPojo(JsonUtils.java:48) at com.express.web.controller.backstage.ManagerBaseController.getCurrentUser(ManagerBaseController.java:29) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.method.annotation.ModelFactory.invokeModelAttributeMethods(ModelFactory.java:142) at org.springframework.web.method.annotation.ModelFactory.initModel(ModelFactory.java:111) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:872) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942)   这个错误产生的原因有三个：
1. 是因为在使用ObjectMapper将json转为对象时，会默认调用该对象的无参构造函数，因此在该对象类中加入无参构造函数即可去掉该错误。
2. 期待转成的对象与json对应的属性不匹配。
3. 真正的空指针，既json为空。
ajax提交的几个坑  通过ajax提交数据，在后台是无法进行重定向的，只能通过前端进行重定向。具体如何实现如下：
* 判断满足需要重定向时，需要修改返回前端的Header以及Status，并设置拦截（当然这个可以不用）。
* 编写redirectUtil工具类,处理后台跳转，这里需要注意，设置 response.setStatus(HttpServletResponse.SC_FORBIDDEN);之后前端会被拦截，报403错误，代表服务端终止，前端进行操作。
 /** *@author fyzn12 *@version 1.0 *@date 2020/4/18 13:46 *主要作用于ajax请求，后台重定向 *提供日志接口 *提供获取具体日志对象的方法 */ @Slf4j public class RedirecUtil { public static void redirect(HttpServletRequest request,HttpServletResponse response,String redirectUrl){ try { /* *如果是ajax请求 **/ String ajax = &amp;quot;XMLHttpRequest&amp;quot;; String header = &amp;quot;X-Requested-With&amp;quot;; if(ajax.</description>
    </item>
    
    <item>
      <title>mybatis之动态SQL</title>
      <link>https://fyzn12.github.io/post/mybatis/dynamicsql/</link>
      <pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/mybatis/dynamicsql/</guid>
      <description>动态SQL语句总结 主要内容  if元素
 choose、when、otherwise元素 trim、where、set元素 foreach元素  if 元素 下面先看一个例子
 &amp;lt;select id=&amp;quot;selectUserById&amp;quot; resultType=&amp;quot;MyUser&amp;quot; parameterType=&amp;quot;MyUser&amp;quot;&amp;gt; select * from user where 1=1 &amp;lt;if test =&amp;quot;name !=null and name !=&#39;&#39;&amp;quot;&amp;gt; and name like concat(&#39;%&#39;,#{name},&#39;%&#39;) &amp;lt;/if&amp;gt; &amp;lt;if test = &amp;quot;sex !=null and sex !=&#39;&#39;&amp;quot;&amp;gt; and sex = #{sex} &amp;lt;/if&amp;gt; &amp;lt;/select&amp;gt;  在上面的例子中，运用的是sql语句的拼接，在这里需要注意的是有如下几点：
 1. resultType与resultMap不能同时使用 2. #{xxx}与${vlaue}的使用看上一篇博客 3. if的判断条件的test里面的参数目前我知道有三种声明方式如下： 1）对象作为参数，则test里面的参数为对象的属性 2)@Param声明的参数 3)map方式键值对  choose、when 、otherwise元素 有些时候不想用到所以的条件语句，而只想从中选择一二，针对这种情况，Mybatis提供了&amp;lt;choose&amp;gt;元素，如下例子。
 &amp;lt;select id = &amp;quot;selectUserBychoose&amp;quot; resultType=&amp;quot;MyUser&amp;quot; parameterType=&amp;quot;MyUser&amp;quot;&amp;gt; select * from user where 1=1 &amp;lt;choose&amp;gt; &amp;lt;when test=&amp;quot;name !</description>
    </item>
    
    <item>
      <title>mybatis之mapper接口编程</title>
      <link>https://fyzn12.github.io/post/mybatis/mapper%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/mybatis/mapper%E7%BC%96%E7%A8%8B/</guid>
      <description>面向接口编程的思路  创建pojo（javaBean）类
 创建接口
 创建接口对应的mapper文件
注意：
1）mapper文件名必须和接口名相同，如接口名为ITeacher则mapper名为ITeacher（并且在同一个包下，实践得到）,如果使用扫描包的方式，那么两者必须在同一个包下，如
 
  如果用读取文件的方式，则不用在同一个包下如下
&amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;quot;mapper/*.xml&amp;quot;/&amp;gt; &amp;lt;/mappers&amp;gt;  2）mapper文件的namespace取值必须和接口的全路径相同
3）mapper中的SQL声明的id必须和接口中的方法名相同，如接口中声明方法seleteAll则sql的id必须为seleteAll
4）多参传递可以不写parameterType属性
5）参数的下标书写 &amp;lt;selete * from teacher where name=#{0} and age=#{1}表示方法中传的参数的第一个参数和第二个参数
6）参数的占位书写
7）参数的声明书写 方法中用@Param声明。
4. 读取mybatis-config.xml文件获取数据库的连接，以及读取mapper文件，得到InputStream对象，创建SqlSessionFactory对象，利用SqlSessionFactory对象建立session连接通过openSession（）方法
InputStream is; try { //1.利用org.apache.ibatis.io.Resources方法读取mybatis-config.xml is = Resources.getResourceAsStream(&amp;quot;mybatis-config.xml&amp;quot;); // 2.通过文件流,创建一个sqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder() .build(is); // 3.通过工厂创建一个数据库的连接session session = factory.openSession(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); }  &amp;emsp;</description>
    </item>
    
    <item>
      <title>Mybatis-的配置文件</title>
      <link>https://fyzn12.github.io/post/mybatis/mybatis01/</link>
      <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/mybatis/mybatis01/</guid>
      <description>Mybatis的配置文件以及mapper文件 在mybatis的配置文件中，所有的配置均是在 &amp;lt;configuration&amp;gt;&amp;lt;/configuration&amp;gt;`这对标签里配置。在这里记录一些课堂老师讲解的重要配置。  &amp;lt;configuration&amp;gt; 1.配置日志（开启日志）通过```&amp;lt;settings&amp;gt;&amp;lt;/settings&amp;gt;```标签配置，如下所示： &amp;lt;!-- 开启日志 --&amp;gt; &amp;lt;settings&amp;gt; &amp;lt;setting name=&amp;quot;logImpl&amp;quot; value=&amp;quot;LOG4J&amp;quot;/&amp;gt; &amp;lt;/settings&amp;gt; 2.为了提高效率，在mapper文件不用每个resultType属性里都添加包名，设置别名。设置在typeAliases标签里，如下两种方式配置，优点和缺点 &amp;lt;typeAliases&amp;gt; &amp;lt;typeAlia type=&amp;quot;com.pojo.Student&amp;quot;alias=&amp;quot;Student&amp;quot;/&amp;gt;--方法一 缺点：有多少个类，就得有多少行这个代码 &amp;lt;!-- 或者&amp;lt;package name=&amp;quot;com.pojo/&amp;gt;&amp;quot; --方法二 缺点： 在pojo包下如果还有子包，在子包下有与子包同级的类名相同时，会出现歧义，不知指定的是哪个包。 &amp;lt;/typeAliases&amp;gt;  3.数据库连接的配置
 &amp;lt;environments default=&amp;quot;default&amp;quot;&amp;gt; &amp;lt;!--配置多个数据源,但只能指定一个使用 --&amp;gt; &amp;lt;!-- Mysql的数据库链接 --&amp;gt; &amp;lt;environment id=&amp;quot;default&amp;quot;&amp;gt; &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;&amp;lt;!-- 指定当前数据库的事务管理方式 --&amp;gt; &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;&amp;lt;!-- 数据源的管理方式为连接池 --&amp;gt; &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;dbc:mysql://localhost:3306/ssmLab4046?serverTimezone=GMT%2B8&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;1234&amp;quot;/&amp;gt; &amp;lt;!-- 设定数据库的链接4要素 --&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt;  4.映射文件的扫面通过标签配置。
 &amp;lt;!-- 一定是文件格式--&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;quot;com/mapper/StudentMapper.</description>
    </item>
    
    <item>
      <title>Emoji Support</title>
      <link>https://fyzn12.github.io/post/emoji-support/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/emoji-support/</guid>
      <description>&lt;p&gt;Emoji can be enabled in a Hugo project in a number of ways.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fyzn12.github.io/about/desc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/about/desc/</guid>
      <description>(我以为上帝为我关上了一扇门，会为我打开一扇窗，谁知再关上门的同时，把窗也锁了 可笑又可悲！)
每个人都有一个死角， 自己走不出来，别人也闯不进去。 我把最深沉的秘密放在那里。 你不懂我，我不怪你。
每个人都有一道伤口， 或深或浅，盖上布，以为不存在。 我把最殷红的鲜血涂在那里。 你不懂我，我不怪你。
每个人都有一场爱恋， 用心、用情、用力，感动也感伤。 我把最炙热的心情藏在那里。 你不懂我，我不怪你。
每个人都有一行眼泪， 喝下的冰冷的水，酝酿成的热泪。 我把最心酸的委屈汇在那里。 你不懂我，我不怪你。
每个人都有一段告白， 忐忑、不安，却饱含真心和勇气。 我把最抒情的语言用在那里。 你不懂我，我不怪你。
你永远也看不见我最爱你的时候， 因为我只有在看不见你的时候，才最爱你。 同样， 你永远也看不见我最寂寞的时候， 因为我只有在你看不见我的时候，我才最寂寞。
也许，我太会隐藏自己的悲伤。 也许，我太会安慰自己的伤痕。 也许，你眼中的我，太会照顾自己， 所以，你从不考虑我的感受。
你以为，我可以很迅速的恢复过来，有些自私的以为。 从阴雨走到艳阳，我路过泥泞、路过风。 一路走来，你不曾懂我，我亦不曾怪你。
我不是为了显示自己的大度， 也不是为了体现自己的大方。 只想让你知道，感情不在，责备也不存在。</description>
    </item>
    
  </channel>
</rss>