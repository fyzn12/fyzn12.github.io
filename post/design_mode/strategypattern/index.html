<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>策略模式 - fyzn12的博客</title>

<meta name="description" content="1 OO設計原則 OO設計的五大原則  单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。
 开放封闭原则：实现开放封闭的核心思想就是对抽象编程，而不是对具体编程，因为抽象相对稳定。
 依赖倒置原则：依赖抽象，不要依赖具体。 里氏代换原则：子类型必须能够替换到他们的父类型。主要着眼于对抽象和多态简历在继承的基础上
 接口隔离原则：多个和客户相关的接口要好于一个通用接口
  2 设计模式————策略模式 2.1 策略模式原理 分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里放具体设定行为对象。 原则就是：分离变化部分，封装接口，基于接口编程实现各种功能。此模式让行为算法的变化独立于算法的使用者。 2.2 策略模式设计的代码分析————模拟鸭子项目 2.2.1 抽象出鸭子的行为，鸭子具有飞行能力和叫声，抽象出该接口 package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:42 * @description:会飞的鸭子 */ public interface FlyBehavior { void fly(); } package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:43 * @description:叫声 */ public interface QuackBehavior { void quack(); } 2." /><meta name="keywords"
  content="fyzn12, java, 网络安全, 红蓝攻防, 渗透测试, bypass, waf, 注入, 黑客, chabug" />


<link rel="stylesheet" href="https://fyzn12.github.io/css/main.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.12/src/css/lightgallery.css">



<meta property="og:title" content="策略模式" />
<meta property="og:description" content="1 OO設計原則 OO設計的五大原則  单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。
 开放封闭原则：实现开放封闭的核心思想就是对抽象编程，而不是对具体编程，因为抽象相对稳定。
 依赖倒置原则：依赖抽象，不要依赖具体。 里氏代换原则：子类型必须能够替换到他们的父类型。主要着眼于对抽象和多态简历在继承的基础上
 接口隔离原则：多个和客户相关的接口要好于一个通用接口
  2 设计模式————策略模式 2.1 策略模式原理 分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里放具体设定行为对象。 原则就是：分离变化部分，封装接口，基于接口编程实现各种功能。此模式让行为算法的变化独立于算法的使用者。 2.2 策略模式设计的代码分析————模拟鸭子项目 2.2.1 抽象出鸭子的行为，鸭子具有飞行能力和叫声，抽象出该接口 package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:42 * @description:会飞的鸭子 */ public interface FlyBehavior { void fly(); } package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:43 * @description:叫声 */ public interface QuackBehavior { void quack(); } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fyzn12.github.io/post/design_mode/strategypattern/" />
<meta property="article:published_time" content="2020-09-02T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-09-02T00:00:00+00:00" />
<meta itemprop="name" content="策略模式">
<meta itemprop="description" content="1 OO設計原則 OO設計的五大原則  单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。
 开放封闭原则：实现开放封闭的核心思想就是对抽象编程，而不是对具体编程，因为抽象相对稳定。
 依赖倒置原则：依赖抽象，不要依赖具体。 里氏代换原则：子类型必须能够替换到他们的父类型。主要着眼于对抽象和多态简历在继承的基础上
 接口隔离原则：多个和客户相关的接口要好于一个通用接口
  2 设计模式————策略模式 2.1 策略模式原理 分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里放具体设定行为对象。 原则就是：分离变化部分，封装接口，基于接口编程实现各种功能。此模式让行为算法的变化独立于算法的使用者。 2.2 策略模式设计的代码分析————模拟鸭子项目 2.2.1 抽象出鸭子的行为，鸭子具有飞行能力和叫声，抽象出该接口 package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:42 * @description:会飞的鸭子 */ public interface FlyBehavior { void fly(); } package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:43 * @description:叫声 */ public interface QuackBehavior { void quack(); } 2.">


<meta itemprop="datePublished" content="2020-09-02T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-09-02T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="799">



<meta itemprop="keywords" content="策略模式," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="策略模式"/>
<meta name="twitter:description" content="1 OO設計原則 OO設計的五大原則  单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。
 开放封闭原则：实现开放封闭的核心思想就是对抽象编程，而不是对具体编程，因为抽象相对稳定。
 依赖倒置原则：依赖抽象，不要依赖具体。 里氏代换原则：子类型必须能够替换到他们的父类型。主要着眼于对抽象和多态简历在继承的基础上
 接口隔离原则：多个和客户相关的接口要好于一个通用接口
  2 设计模式————策略模式 2.1 策略模式原理 分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里放具体设定行为对象。 原则就是：分离变化部分，封装接口，基于接口编程实现各种功能。此模式让行为算法的变化独立于算法的使用者。 2.2 策略模式设计的代码分析————模拟鸭子项目 2.2.1 抽象出鸭子的行为，鸭子具有飞行能力和叫声，抽象出该接口 package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:42 * @description:会飞的鸭子 */ public interface FlyBehavior { void fly(); } package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:43 * @description:叫声 */ public interface QuackBehavior { void quack(); } 2."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>

<body>
    <div class="header-placeholder"></div>
    
    <header class="header">
        <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    
    <a class="site-title" href="https://fyzn12.github.io/">fyzn12</a>
    
    <nav class="site-nav">
        <a class="page-link" href="/">Home</a><a class="page-link" href="/post/">Category</a><a class="page-link" href="/about">About</a>
    </nav>
</div>

    </header>

    
    <div class="page-content">
        <div class="wrapper">
            
            <div class="col-main">
                <div class="post">
    
    <header class="post-header">
        <h1 class="post-title">策略模式</h1>
        <p class="post-meta">Sep 02, 2020</p>
    </header>
    <article class="post-content">
        
        
        
        
        
        
        

<h1 id="1-oo設計原則">1 OO設計原則</h1>

<h2 id="oo設計的五大原則">OO設計的五大原則</h2>

<ul>
<li>单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。<br /></li>
<li>开放封闭原则：实现开放封闭的核心思想就是对抽象编程，而不是对具体编程，因为抽象相对稳定。<br /></li>
<li>依赖倒置原则：依赖抽象，不要依赖具体。</li>
<li>里氏代换原则：子类型必须能够替换到他们的父类型。主要着眼于对抽象和多态简历在继承的基础上<br /></li>
<li>接口隔离原则：多个和客户相关的接口要好于一个通用接口<br />

<br /></li>
</ul>

<h1 id="2-设计模式-策略模式">2 设计模式————策略模式</h1>

<h2 id="2-1-策略模式原理">2.1 策略模式原理</h2>

<h4 id="分别封装行为接口-实现算法族-超类里放行为接口对象-在子类里放具体设定行为对象">分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里放具体设定行为对象。</h4>

<hr />

<h4 id="原则就是-分离变化部分-封装接口-基于接口编程实现各种功能-此模式让行为算法的变化独立于算法的使用者">原则就是：分离变化部分，封装接口，基于接口编程实现各种功能。此模式让行为算法的变化独立于算法的使用者。</h4>

<h2 id="2-2-策略模式设计的代码分析-模拟鸭子项目">2.2 策略模式设计的代码分析————模拟鸭子项目</h2>

<h3 id="2-2-1-抽象出鸭子的行为-鸭子具有飞行能力和叫声-抽象出该接口">2.2.1 抽象出鸭子的行为，鸭子具有飞行能力和叫声，抽象出该接口</h3>
<div class="highlight"><pre class="chroma">            <span class="kn">package</span> <span class="nx">com</span><span class="p">.</span><span class="nx">fyzn12</span><span class="p">.</span><span class="nx">api</span><span class="p">;</span>

            <span class="cm">/**
</span><span class="cm">             * @author ZhangRongJun
</span><span class="cm">             * @version 1.0
</span><span class="cm">             * @date 2020/9/2 10:42
</span><span class="cm">             * @description:会飞的鸭子
</span><span class="cm">             */</span>
            <span class="nx">public</span> <span class="kd">interface</span> <span class="nx">FlyBehavior</span> <span class="p">{</span>
                <span class="nx">void</span> <span class="nf">fly</span><span class="p">();</span>
            <span class="p">}</span>  


            <span class="kn">package</span> <span class="nx">com</span><span class="p">.</span><span class="nx">fyzn12</span><span class="p">.</span><span class="nx">api</span><span class="p">;</span>

            <span class="cm">/**
</span><span class="cm">             * @author ZhangRongJun
</span><span class="cm">             * @version 1.0
</span><span class="cm">             * @date 2020/9/2 10:43
</span><span class="cm">             * @description:叫声
</span><span class="cm">             */</span>
            <span class="nx">public</span> <span class="kd">interface</span> <span class="nx">QuackBehavior</span> <span class="p">{</span>
                <span class="nx">void</span> <span class="nf">quack</span><span class="p">();</span>
            <span class="p">}</span></pre></div>
<h3 id="2-2-2-对鸭子抽象出来的具体行为进行实现">2.2.2 对鸭子抽象出来的具体行为进行实现</h3>
<div class="highlight"><pre class="chroma">            /**
             * @author ZhangRongJun
             * @version 1.0
             * @date 2020/9/2 10:51
             * @description:会飞鸭子的实现
             */
            public class GoodFlyBehavio implements FlyBehavior {
                @Override
                public void fly() {
                    System.out.println(&#34;会飞鸭子的实现&#34;);
                }
            }  


            /**
             * @author ZhangRongJun
             * @version 1.0
             * @date 2020/9/2 10:52
             * @description:叫声
             */
            public class GaGaQuackBehavio implements QuackBehavior {
                @Override
                public void quack() {
                    System.out.println(&#34;叫声不同的体现&#34;);
                }
            }  </pre></div>
<h3 id="2-2-3-对鸭子抽象总行为">2.2.3 对鸭子抽象总行为</h3>
<div class="highlight"><pre class="chroma">            /**
             * @author ZhangRongJun
             * @version 1.0
             * @date 2020/9/2 10:44
             * @description:定义鸭子的行为
             */
            public abstract class Duck {
                protected FlyBehavior flyBehavior;
                protected QuackBehavior quackBehavior;

                public Duck() {
                }

                public void fly() {
                    flyBehavior.fly();
                }

                public void quack() {
                    quackBehavior.quack();
                }

                public abstract void display();
            }   </pre></div>
<h3 id="2-2-3-对鸭子抽象总行为进行实现">2.2.3 对鸭子抽象总行为进行实现</h3>
<div class="highlight"><pre class="chroma">            /**
             * @author ZhangRongJun
             * @version 1.0
             * @date 2020/9/2 10:47
             * @description:环境角色
             */
            public class GreenHeadDuck extends Duck {
                public GreenHeadDuck() {
                    flyBehavior = new GoodFlyBehavio();
                    quackBehavior = new GaGaQuackBehavio();
                }

                @Override
                public void display() {
                    fly();
                    quack();
                }


                public static void main(String[] args) {
                    GreenHeadDuck duck = new GreenHeadDuck();
                    duck.display();
                }
            }    </pre></div>
<h2 id="2-3-策略模式的优缺点">2.3 策略模式的优缺点</h2>

<h3 id="优点-1-算法可以自由切换-2-避免使用多重条件判断-3-扩展性好">优点：1. 算法可以自由切换；2. 避免使用多重条件判断；3. 扩展性好</h3>

<h3 id="缺点-1-策略类会增多-2-所有策略类都需要对外暴露">缺点：1. 策略类会增多；2. 所有策略类都需要对外暴露</h3>

<h2 id="2-4-策略模式中有三个对象">2.4 策略模式中有三个对象：</h2>

<ol>
<li>环境对象：该类中实现了对抽象策略中定义的接口或者抽象类的引用。</li>
<li>抽象策略对象：它可由接口或抽象类来实现。</li>
<li>具体策略对象：它封装了实现同不功能的不同算法。
<br />
<br /></li>
</ol>

<h2 id="2-5-策略模式的核心实现项目">2.5 策略模式的核心实现项目</h2>

<h3 id="2-5-1-定义一个事件-使用枚举类型进行包装">2.5.1 定义一个事件，使用枚举类型进行包装</h3>
<div class="highlight"><pre class="chroma">        /**
         * @author ZhangRongJun
         * @version 1.0
         * @date 2020/9/2 14:52
         * @description:事件的定义
         */
        public enum EventEnum {
            ERROR(&#34;error&#34;, &#34;异常中断&#34;),
            CLOSE(&#34;close&#34;, &#34;正常关闭&#34;),
            LOGIN(&#34;login&#34;, &#34;登录&#34;),
            HEALTHY(&#34;healthy&#34;, &#34;健康监测&#34;);
            private String value;
            private String desc;

            EventEnum(String value, String desc) {
                this.value = value;
                this.desc = desc;
            }

            public String getValue() {
                return value;
            }

            public void setValue(String value) {
                this.value = value;
            }

            public String getDesc() {
                return desc;
            }

            public void setDesc(String desc) {
                this.desc = desc;
            }
        }  </pre></div>
<h3 id="2-5-2-首先编写参数类-返回结果类">2.5.2 首先编写参数类、返回结果类</h3>
<div class="highlight"><pre class="chroma">        /**
         * @author ZhangRongJun
         * @version 1.0
         * @date 2020/9/2 15:00
         * @description:请求通用参数
         */
        public class HandlerParam&lt;T&gt; {
            /**
             * @description:事件类型
             */
            private EventEnum event;
            /**
             * @description:请求业务的参数
             */
            private T param;

            public HandlerParam(EventEnum event) {
                this.event = event;
            }

            public HandlerParam(EventEnum event, T param) {
                this.event = event;
                this.param = param;
            }

            public EventEnum getEvent() {
                return event;
            }

            public void setEvent(EventEnum event) {
                this.event = event;
            }

            public T getParam() {
                return param;
            }

            public void setParam(T param) {
                this.param = param;
            }

            @Override
            public String toString() {
                return &#34;HandlerParam{&#34; +
                        &#34;event=&#34; + event +
                        &#34;, param=&#34; + param +
                        &#39;}&#39;;
            }
        }   </pre></div>
<h4 id="该类包装了一个返回值事件evenenum以及请求参数类型-t">该类包装了一个返回值事件EvenEnum以及请求参数类型 T</h4>
<div class="highlight"><pre class="chroma">        /**
         * @author ZhangRongJun
         * @version 1.0
         * @date 2020/9/2 14:47
         * @description:定义结果返回的类
         */
        public class HandlerResult&lt;T&gt; {
            /**
             * 返回结果对象
             */
            private T result;


            public HandlerResult() {
            }

            /**
             * @Param: result 返回结果的类型
             * @description:TODO
             * @Return
             */
            public HandlerResult(T result) {
                this.result = result;
            }

            public T getResult() {
                return result;
            }

            public void setResult(T result) {
                this.result = result;
            }

            @Override
            public String toString() {
                return &#34;HandlerResult{&#34; +
                        &#34;result=&#34; + result +
                        &#39;}&#39;;
            }
        }</pre></div>
<h4 id="该类主要返回一个-t-的类型的返回值">该类主要返回一个 T 的类型的返回值</h4>

<h3 id="2-5-3-编写抽象策略对象-抽象策略对象">2.5.3 编写抽象策略对象————抽象策略对象</h3>
<div class="highlight"><pre class="chroma">        /**
         * @author ZhangRongJun
         * @version 1.0
         * @date 2020/9/2 14:44
         * @description:定义业务处理方法和处理业务的类型。
         */
        public abstract class AbstractHandler {

            /**
             * @Param: param
             * @description:业务处理
             * @Return
             */
            public abstract HandlerResult strategy(HandlerParam param);

            /**
             * @Param:
             * @description:返回业务类型,可以配置多个事件也可以是单个事件
             * @Return
             */
            public abstract List&lt;EventEnum&gt; eventTypes();


        }  </pre></div>
<h3 id="2-5-4-编写抽象策略对象的子类-具体策略对象">2.5.4 编写抽象策略对象的子类————具体策略对象</h3>
<div class="highlight"><pre class="chroma">        /**
         * @author ZhangRongJun
         * @version 1.0
         * @date 2020/9/2 15:28
         * @description:TODO
         */
        @Component
        public class LoginHandler extends AbstractHandler {
            @Override
            public HandlerResult strategy(HandlerParam param) {
                //根据参数进行业务处理
                System.out.println(&#34;业务处理&#34;);

                //返回结果
                return new HandlerResult&lt;String&gt;(&#34;业务处理完毕&#34;);
            }

            @Override
            public List&lt;EventEnum&gt; eventTypes() {
                return Arrays.asList(EventEnum.LOGIN, EventEnum.HEALTHY);
            }
        }</pre></div>
<h4 id="这里多个子类的区分主要是通过eventtypes方法中定义的集合区分">这里多个子类的区分主要是通过eventTypes方法中定义的集合区分</h4>

<h3 id="2-5-5-编写暴露接口-环境对象">2.5.5 编写暴露接口————环境对象</h3>
<div class="highlight"><pre class="chroma">        /**
         * @author ZhangRongJun
         * @version 1.0
         * @date 2020/9/2 15:13
         * @description:暴露接口类
         * 实现ApplicationContextAware接口，获取springboot的容器
         */
        @Service
        public class ContextHandlerService implements ApplicationContextAware {
            /**
             * 实现ApplicationContextAware接口获取springboot容器对象
             * 方便创建完成对象后进行初始化
             */
            private static final Map&lt;EventEnum, AbstractHandler&gt; HANDLER_MAP = new HashMap&lt;&gt;();
            private ApplicationContext applicationContext;

            @Override
            public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
                this.applicationContext = applicationContext;
            }

            /**
             * @PostConstruct 声明在创建完成对象并且注入属性后执行该方法
             */
            @PostConstruct
            public void init() {
                //获取AbstractHandler的所有实现类
                Map&lt;String, AbstractHandler&gt; type = applicationContext.getBeansOfType(AbstractHandler.class);
                for (Map.Entry&lt;String, AbstractHandler&gt; entry : type.entrySet()) {
                    //获取单个实现类
                    AbstractHandler value = entry.getValue();
                    if (value.eventTypes() == null) {
                        continue;
                    }
                    //或者注册事件
                    for (EventEnum eventEnum : value.eventTypes()) {
                        HANDLER_MAP.put(eventEnum, value);
                    }
                }
            }
            /**
             * @Param: param
             * @description:业务处理类的路由方法
             * @Return 
            */
            public HandlerResult strategy(HandlerParam param){
                //这个位置会根据事件类型决定走那个决策类。
                AbstractHandler abstractHandler = HANDLER_MAP.get(param.getEvent());
                if (abstractHandler==null){
                    return null;
                }
                return abstractHandler.strategy(param);
            }
        }  </pre></div>
<h3 id="2-5-6-编写测试类">2.5.6 编写测试类</h3>
<div class="highlight"><pre class="chroma">        /**
         * @author ZhangRongJun
         * @version 1.0
         * @date 2020/9/2 15:30
         * @description:TODO
         */
        @RunWith(SpringRunner.class)
        @SpringBootTest(classes = StrategyTest.class)
        @ComponentScan(basePackages = &#34;com.fyzn12.service&#34;)
        public class StrategyTest {

            @Autowired
            private ContextHandlerService service;


            @Test
            public void test() {
                if (service==null){
                    System.out.println(&#34;空&#34;);
                }
                //定于路由参数即可
                HandlerParam&lt;String&gt; param = new HandlerParam&lt;&gt;(EventEnum.HEALTHY, &#34;我是参数&#34;);
                System.out.println(&#34;请求参数：&#34; + param);
                HandlerResult result = service.strategy(param);
                System.out.println(&#34;返回结果&#34; + result);

            }
        }</pre></div>
<h4 id="这个位置值得注意的是-当测试类并不是在测试环境下时-要求加上-componentscan-basepackages-com-fyzn12-service-对暴露接口类的扫描-不然在注入private-contexthandlerservice-service时会提示找不到contexthandlerservice类">这个位置值得注意的是，当测试类并不是在测试环境下时，要求加上@ComponentScan(basePackages = &ldquo;com.fyzn12.service&rdquo;)对暴露接口类的扫描，不然在注入private ContextHandlerService service时会提示找不到ContextHandlerService类。</h4>

    </article>

    
    <div class="prevnext">
        



<ul class="prevnext">
    
    <li>上一篇：
        <a href="https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zuul%E7%BD%91%E5%85%B3/">
            SpringCloud微服务网关技术Zuul
        </a>
    </li>
    
    
    <li>下一篇：
        <a href="https://fyzn12.github.io/post/spring-boot/springboot-information/">
            SpringBoot优点
        </a>
    </li>
    
</ul>

    </div>
    
    <div class="post-comments">
        
  
  

  
    <script src="https://utteranc.es/client.js"
            repo="fyzn12/Y4er.com"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </div>
</div>
            </div>
            
            <div class="col-second">
                <div class="col-box col-box-author">
    <img class="avatar" src="https://fyzn12.github.io/images/header.jpg" alt="fyzn12">
    <div class="col-box-title name">fyzn12</div>
    <p>哀吾生之须臾,羡长江之无穷.</p>
    <p class="contact">
        <a href="fyzn12_z@163.com">Email</a>
        <a href="https://fyzn12.github.io">Github</a>
    </p>
</div>

<div class="col-box">
    <div class="col-box-title">Newest Posts</div>
    <ul class="post-list">
        
        <li>
            <a href="https://fyzn12.github.io/about/" class="post-link">About</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/algorithm/linkedlist/" class="post-link">LinkedList以及栈的深度理解</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/design_mode/singleton/" class="post-link">单例模式</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/design_mode/factory-pattern/" class="post-link">工厂模式</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/design_mode/decorator_design/" class="post-link">装饰者模式</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/springboot%E6%95%B4%E5%90%88redis%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%BC%93%E5%AD%98/" class="post-link">SpringBoot整合Redis使用注解实现同步缓存</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/design_mode/observer/" class="post-link">观察者模式</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/database/transaction/" class="post-link">数据库的事务</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/spring-boot/springboot-information/" class="post-link">SpringBoot优点</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/design_mode/strategypattern/" class="post-link">策略模式</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zuul%E7%BD%91%E5%85%B3/" class="post-link">SpringCloud微服务网关技术Zuul</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/" class="post-link">SpringCloud整合Zookeeper注册中心</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" class="post-link">Java基础底层</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-link">多线程</a>
        </li>
        
        <li>
            <a href="https://fyzn12.github.io/post/spring-boot/spring-data/" class="post-link">Spring Boot整合Spring Data JPA</a>
        </li>
        
    </ul>
</div>

<div class="col-box post-toc hide">
    <div class="col-box-title">TOC</div>
</div>
            </div>
        </div>
    </div>
    
    <footer class="footer">
        <div class="wrapper">
    © 2020    <a href="https://fyzn12.github.io/">fyzn12</a>
</div>
    </footer>
    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@1.11.0/dist/jquery.min.js"></script>

<script src="/js/easybook.js"></script>

<script src="/js/lazysizes.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.12/dist/js/lightgallery-all.min.js"></script>
<script src="/js/figure.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-XXXXXXXX-X', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>






</body>

</html>