<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on fyzn12的博客</title>
    <link>https://fyzn12.github.io/post/</link>
    <description>Recent content in Posts on fyzn12的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 01 Dec 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://fyzn12.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>字符串</title>
      <link>https://fyzn12.github.io/post/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>最经典的就是寻找最长回文子串的问题
解题思想：回文子串的详细思路 在上面的链接中，对该问题做了很详细的思路讲解 下面自己实现采用 Manacher 算法，被中国程序员戏称为“马拉车”算法。它专门用于解决“最长回文子串”问题，时间复杂度为O(N) 。
 public int getLongestPalindrome(String A, int n) { // 做字符串的预处理  String str = changeStr(A,&amp;#39;#&amp;#39;); // 定义左跳跃的指针和右跳跃的指针以及最长回文串的返回值  int left=0,right=0,max=0; for(int i = 1;i&amp;lt;str.length();i++) { //判断每一步扩散的步数  right = i + 1; left = i - 1; int count = 0; while (left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; str.length() &amp;amp;&amp;amp; str.charAt(left) == str.charAt(right)) { count++; left--; right++; } max = max &amp;gt; count ?</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E7%BB%84/</guid>
      <description>总结与数组有关的算法题：
数组的概念：占据一块连续的内存，并按照顺序存储数组。
算法题： 在一个二维数组中，每一行都按照从左右到右顺序排序，每一列从上到下都按照顺序排序。给定一个数，若存在于数组中则返回true
 public static Boolean checkNum(int[][] arr,int target){ int row = 0; int column = arr[0].length-1; while (row&amp;lt;arr.length &amp;amp;&amp;amp; column &amp;gt;=0){ if (arr[row][column]==target){ return true; } if (arr[row][column]&amp;gt;target){ column--; }else { row++; } } return false; }  1.判断一个数是奇数还是偶数的方法  使用除2取余的方式 如 4%2 判断余数是否为0，是则为偶数，不是则为奇数 将判断的数与1做按位与运算，结果为1则为奇数，为0则为偶数
  2.交换两个数字的位置  使用第三变量 如 int tmp = a; a = b;b = tmp; 使用异或运算 如 a ^= b; b ^= a; a ^= b;这样既可将两个数字交换位置</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8/</guid>
      <description>  题目：输入一个链表，反转链表后，输出新链表的表头。
 1 分析  假如链表的初始化状态如下图所示：    要将链表反转，只需要将链表中的指针反转，第一个链表的指针指向为 null的链表即可
 定义三个指针 p1,p2,p3 其中p1执行为null的链表，p2，指向第一个链表，p3指向第2个链表；如下图所示；
   4. 下面需要将p2指针指向p1   将p3的指针指向p2，依次执行，知道执行到最后一个链表即可
  2. 代码实现如下图所示 public ListNode ReverseList(ListNode head) { if(head==null) return null; ListNode p1 = null; ListNode p2 = head; ListNode p3 = head.next; while(p2 != null){ p2.next = p1; p1 = p2; p2 = p3; if(p3 != null ){ p3 = p3.next; } } return p1; } </description>
    </item>
    
    <item>
      <title>常见算法的实现</title>
      <link>https://fyzn12.github.io/post/faceword/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/faceword/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>问题描述：
给定一个数组arr，返回arr的最长无的重复子串的长度(无重复指的是所有数字都不相同)。
例如： 输入：[2,3,4,5] 输出：4 输入：[2,2,3,4,3] 输出：3
   public int maxLength (int[] arr) { // write code here  Map&amp;lt;Integer,Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(); if(arr==null || arr.length==0) return 0; if(arr.length==1)return 1; int left = 0,right = 0,max=0; for(int tmp = 0;right&amp;lt;arr.length;right++){ int cur = arr[right]; if(map.containsKey(cur) &amp;amp;&amp;amp; map.get(cur) &amp;gt;= left){ tmp = right-left; left = map.get(cur)+1; } if(max==0 &amp;amp;&amp;amp; tmp == 0 &amp;amp;&amp;amp; (right+1)== arr.length){ // 解决数组从第一个到最后一个都是不一样的数据长度问题  max = right-left+1; } map.</description>
    </item>
    
    <item>
      <title>mysql基础底层</title>
      <link>https://fyzn12.github.io/post/database/mysql/</link>
      <pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/database/mysql/</guid>
      <description>MYSQL的一些基础底层
 1. 数据库应用的分类  一类是OLTP：在线事务处理，如博客、电子商务、网络游戏；
另一类OLAP：在线分析处理，如数据仓库、数据集市； 对于OLAP的应用，分区的确可以很好的提高查询的性能；
 2. MYSQL的慢查询  通过 long_query_time 设置阈值，默认是10，代表10秒； 默认情况下，mysql并不启动慢查询日志，需要手工设置 log_slow_queries设置为ON开启慢查询日志。
 3. InnoDB存储引擎表类型  在InnoDB存储引擎表中，每张表都有一个主键，如果在创建表时没有显示地定义主键，则InnoDB存储引擎会按如下的方式选择创建主键。
  寻找加了unique约束并且不为NULL的列设为主键。
 如果没有，把row_id作为主键
 InnoDB在每行记录都添加了三个隐藏字段
 DB_ROW_ID &amp;mdash;6个字节：行的标识；
 DB_TRX_ID &amp;mdash;6个字节：新增更新行的最后一个事务ID，自动递增（创建版本号，数据库的乐观锁相似）； DB_ROLL_PTR &amp;mdash;7个字节：回滚指针（删除版本号）
    4. MYSQL分区 1. 分区类型  range（范围） list（离散、不连续） hash（散列） key 子分区 &amp;ndash;在分区的基础上进行分区  关键字 subpartitions
 子分区数量必须相同
  columns分区
  2. 创建方式 create table `table_name`( a int,b int )engin=innodb partition by key(b) partition 4;  另外在MYSQL数据库中还支持一种称为linear hash的分区，他使用一个更加复杂的算法来确定新行插入已经分区表中的位置。 create table `table_name`( a int,b int; )engin=innodb partition by linear hash(b) partition 4; ---指定分区数    linear hash 的优点在于，增加、删除，合并和拆分将变得更加快捷，有利于处理含有大量数据的表；</description>
    </item>
    
    <item>
      <title>SpringBoot结合antd组件Upload实现文件上传</title>
      <link>https://fyzn12.github.io/post/spring-boot/upload/</link>
      <pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/upload/</guid>
      <description>项目实现的背景介绍，当后台采用Spring Security验证信息，用户登录token保存在header中
用户每次请求需要携带对应的header和用户角色的情况时，记录一下问题
前后端分离，后台使用SpringBoot 前端采用antd pro react
 一、 后端编写业务代码过程中遇到的错误点 1. 配置SpringBoot文件上传 ## ******************************* 配置文件上传 *********************************** # 是否启用SpringMVC多分部上传功能 spring.servlet.multipart.enabled=true # 将文件写入磁盘的阀值。值可以使用后缀“MB”或“KB”来表示兆字节或字节大小 spring.servlet.multipart.file-size-threshold=0 # 指定默认上传的文件夹 # spring.servlet.multipart.location=/upload # 限制单个文件最大大小 spring.servlet.multipart.max-file-size=1MB # 限制所有文件最大大小 spring.servlet.multipart.max-request-size=10MB # 是否延迟多部件文件请求的参数和文件的解析 spring.servlet.multipart.resolve-lazily=false ## *********************** 配置静态资源文件 读取静态文件的依赖 *************************************** spring.resources.static-locations=classpath:/static/ # 以jar包发布项目时，我们存储的路径是与jar包同级的static目录，因此我们需要在jar包目录的 # application.properties配置文件中设置静态资源路径，如下所示： # 设置静态资源路径，多个以逗号分隔 # spring.resources.static-locations=classpath:static/,file:static/ spring.mvc.static-path-pattern=/static/**   上面简单的配置实现了springboot上传文件的配置，避免了SpringMVC复杂的xml文件的配置
 以jar包发布项目时，我们存储的路径是与jar包同级的static目录，因此我们需要在jar包目录的application.properties配置文件中设置静态资源路径，如下所示：设置静态资源路径，多个以逗号分隔 spring.resources.static-locations=classpath:static/,file:static/   2. 后端采用SpringMVC的MultipartFile接受前端发过来的参数 @PostMapping(&amp;#34;/modification-avatar&amp;#34;) public Map&amp;lt;String, Object&amp;gt; update(@RequestParam(value = &amp;#34;file&amp;#34;,required = false) MultipartFile file, HttpServletRequest request) throws FileNotFoundException { User user = getUserUtils.</description>
    </item>
    
    <item>
      <title>求两个有序数组的中位数</title>
      <link>https://fyzn12.github.io/post/algorithm/%E5%AF%BB%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E5%AF%BB%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>  给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
 leetcode给出从时间复杂度和空间复杂度最优解分析 方法一：二分查找 给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：
使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。 不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数 组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 000 的位置，每次将指向较小 值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数 的位置。 假设两个有序数组的长度分别为 m 和 n，上述两种思路的复杂度如何？
第一种思路的时间复杂度是 O(m+n)，空间复杂度是 O(m+n)。第二种思路虽然可以将空间复杂度降到 O(1)，但是时间复杂度仍是 O(m+n)。题目要求时间复杂度是 O(log⁡(m+n))，因此上述两种思路都不满足题目要求的时间复杂度。
如何把时间复杂度降低到 O(log⁡(m+n)) 呢？如果对时间复杂度的要求有 log，通常都需要用到二分查找，这道题也可以通过二分查找实现。
根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1。
注意：以上分析思路来自于leetcode官方阶梯思路 </description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://fyzn12.github.io/post/algorithm/tree/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/tree/</guid>
      <description>二叉树的简单介绍
 二叉树的定义 二叉树是(n&amp;gt;=0)个节点的有限集合，他或者(n==0)时为空树，或者（n&amp;gt;0时）由一个根节点及两颗互不相交的分别称为跟的左子树和右子树的二叉树组成。
2 二叉树的遍历 2.1 前序遍历 递归实现的算法分析 前序遍历二叉树的递归定义为：若二叉树为空树则遍历结束，否则
1. 访问根节点
2. 前序遍历根节点的左子树
3. 前序遍历根节点的右子树
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 算法实现 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
public class Tree { private class Bitree&amp;lt;T&amp;gt;{ T data; Bitree lchild; Bitree rchild; public Bitree(T data,Bitree lchild,Bitree rchild){ this.data = data; this.lchild = lchild; this.rchild = rchild; } } private void preorder(Bitree bt){ //设置递归终止条件  if (bt==null){ return; } //输出 跟节点  System.out.println(bt.data); //前序遍历左子树  preorder(bt.lchild); //前序遍历右子树  preorder(bt.rchild); } }  2.</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://fyzn12.github.io/post/design_mode/command-design/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/command-design/</guid>
      <description>  命令模式的简单介绍
 1 命令模式的介绍 1.1 命令模式的结构 </description>
    </item>
    
    <item>
      <title>哈希检索</title>
      <link>https://fyzn12.github.io/post/algorithm/hashtable/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/hashtable/</guid>
      <description>哈希检索算法的深度学习
 1 相关概念的理解 1.1 哈希检索  概念： 哈希检索技术的初衷是组织理想状态的检索表。检索表的理想状态是：把记录的关键字值与记录在检索表中的存储位置建立起某种一对一的关系，这种一对一的关系可以用关键字的一个函数h(key)来表示，这样不必进行关键字与给定值的比较，而是直接依据给定的关键字值来直接计算得到记录在检索表中的存储地址。 哈希函数（散列函数、杂凑函数）：反应关键字与存储位置一对一关系的函数h(key) 哈希检索技术必须解决的两个问题
（1）如何选择一个计算简单且地址冲突尽可能少的哈希函数；
（2）在出现地址冲突时采用什么办法解决冲突
  1.2 哈希函数的构建方法  直接定址法：h(key) = a*key + b 数字分析法：提前知道关键字值的集合，分析关键字集合的分布情况，确定散列函数； 平方取中法：先求出关键字的平方，然后取中间几位作为哈希地址；
 折叠法 除留余数法：h(key) = key % p 余取整法 随机数法：h(key) = random(key)
  2 地址冲突的消解策略 2.1 开放地址法 把哈希表中的空位置向处理地址冲突开放，具体的做法是，当发生地址冲突时，从发生地址冲突的那个位置开始，使用某种方法在哈希表中形成一个探查序列。
2.1.1 线性探查法  线性探查法是开放地址法消除地址冲突的一种最简单的探查方法。他把表长为m的哈希表看成是循环表，若发生地址冲突的位置地址为d，则依次探查d+1, d+2, &amp;hellip;,直到找到一个空闲位置为止。
 公式：（地址）d = (h(key)+i)%m ， 其中i=1,2,&amp;hellip;,m-1
 缺点：线性探查法易造成堆积现象。
  2.1.2 平方探查法  平方探查法也称为二次探查法。在发生地址冲突时，依次探查位置d+i，其中i取 1^2,-1^2,2^2,-2^2,&amp;hellip;, 公式：d = (h(key)+i^2)%m,d = (h(key)-i^2)%m 和中心扩展法相同，以地址冲突的位置，分别向两边去寻找空地址。</description>
    </item>
    
    <item>
      <title>LinkedList以及栈的深度理解</title>
      <link>https://fyzn12.github.io/post/algorithm/linkedlist/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/linkedlist/</guid>
      <description>算法背景:给定一个只包括 &amp;lsquo;(&amp;lsquo;，&amp;rsquo;)&amp;lsquo;，&amp;rsquo;{&amp;lsquo;，&amp;rsquo;}&amp;lsquo;，&amp;rsquo;[&amp;lsquo;，&amp;rsquo;]&amp;rsquo; 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。
 1 首先了解LinkedList的底层实现 1.1 LinkedList的底层实现 LinkedList的底层是基于 双向链表 实现，使用Node存储链表节点信息。源码如下 private static class Node&amp;lt;E&amp;gt; { E item; Node&amp;lt;E&amp;gt; next; Node&amp;lt;E&amp;gt; prev; } 每个链表都存储了first和last指针； transient Node&amp;lt;E&amp;gt; first; transient Node&amp;lt;E&amp;gt; last;   2 设计算法，实现上面的需求 2.1 算法的实现 public static boolean isValid(String s) { int n = s.length(); if (n % 2 == 1) { return false; } Map&amp;lt;Character, Character&amp;gt; pairs = new HashMap&amp;lt;Character, Character&amp;gt;() {{ put(&amp;#39;)&amp;#39;, &amp;#39;(&amp;#39;); put(&amp;#39;]&amp;#39;, &amp;#39;[&amp;#39;); put(&amp;#39;}&amp;#39;, &amp;#39;{&amp;#39;); }}; Deque&amp;lt;Character&amp;gt; stack = new LinkedList&amp;lt;Character&amp;gt;(); for (int i = 0; i &amp;lt; n; i++) { char ch = s.</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://fyzn12.github.io/post/design_mode/singleton/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/singleton/</guid>
      <description>单例模式的介绍
 1 单例模式的原理 确保一个类最多只有一个实例，并提供一个全局的访问点  2 单例模式的创建方式 2.1 饱汉模式（懒汉模式） public class SingleTon{ private SingleTon(){} //实例化放在静态代码块里，可提高程序的执行效率，但也可能更占空间 	private final static SingleTon instance = new SingleTon(); //公共结果，获取对象的实例 	public static SingleTon getInstance(){ return instance; } }  饱汉模式的优点和缺点  优点： 在多线程的情况下，可以保证SingleTon的对象唯一 缺点：在多实例或者有其他静态方法时，在启动时没有使用它的时候就已经加载好了,浪费内存。
  2.2 饥汉模式 public class SingleTon{ private SingleTon(){} private static SingleTon instance = null; public static synchronized SingleTon getInstance(){ if(instance == null){ instance = new SingleTon(); } return instance; } }  饥汉模式的优点和缺点  优点：饥汉模式解决了对象没被使用但却分配了内存空间的问题</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://fyzn12.github.io/post/design_mode/factory-pattern/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/factory-pattern/</guid>
      <description>  工厂模式的简单介绍
 1 简单的工厂模式  原理：定义一个工厂类，根据不同的参数，创建并返回不同的类。其中这些类具有一个公共的父类或是一个接口。  </description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://fyzn12.github.io/post/design_mode/decorator_design/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/decorator_design/</guid>
      <description>  装饰者模式的简单实现
 1 装饰者模式的原理  原理：动态的将新功能添加到对象上。在对象扩展方面，他比继承更具有弹性。
 别人写了一篇易懂的文章装饰者模式
  </description>
    </item>
    
    <item>
      <title>SpringBoot整合Redis使用注解实现同步缓存</title>
      <link>https://fyzn12.github.io/post/springboot%E6%95%B4%E5%90%88redis%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%BC%93%E5%AD%98/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springboot%E6%95%B4%E5%90%88redis%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%BC%93%E5%AD%98/</guid>
      <description>1 SpringBoot整合Redis的环境配置 1.1 添加依赖 &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;druid.version&amp;gt;1.1.9&amp;lt;/druid.version&amp;gt; &amp;lt;!-- mybatis的版本 --&amp;gt; &amp;lt;mybatis.version&amp;gt;3.4.6&amp;lt;/mybatis.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- 配置web启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 配置mybatis--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.15&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 配置数据库连接池 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${druid.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;!--不依赖Redis的异步客户端lettuce--&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;io.lettuce&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lettuce-core&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://fyzn12.github.io/post/design_mode/observer/</link>
      <pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/observer/</guid>
      <description> 1 观察者模式 观察者模式（又被称为发布-订阅模式），属于行为模式的一种，他定义了一种一对多得依赖关系， 让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象， 使他们能够自动更新自己   观察者主要包括以下四个部分   Subject：抽象主题，他把所有观察者对象保存在一个集合里，可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。意思就是明星把所有的粉丝都保存在一个账号里面，粉丝数量不限，可以新增粉丝也可以拉黑粉丝。
 ConcreteSubject：具体主题，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。意思是我们的明星一有动态，就会把消息给粉丝。
 Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。这就是我们所有粉丝的抽象。
 ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。具体每一个粉丝。
  </description>
    </item>
    
    <item>
      <title>数据库的事务</title>
      <link>https://fyzn12.github.io/post/database/transaction/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/database/transaction/</guid>
      <description>1. 数据库的事务 1.1 什么是事务 作为单个逻辑工作单位的一系列操作，要么完全成功，要么完全失败。  1.2 事务的四大特征ACID  A Atomic(原子性)
事务中包含的操作被看作一个整体的业务单元，这样业务单元要么完全成功，要么完全失败。最小的单元  C Consistency(一致性)
事务在完成时，必须使所有的数据都保持一致状态，在数据库中所有的修改都基于事务，保证了数据的完整性  I Isolation(隔离性)
下面将会重点讲解隔离  D Durability(持久性)
事务结束后，所有的数据会固化到一个地方，如保存到磁盘中，即使断电后也可以提供给相应程序访问   1.3 事务的隔离级别  1.3.1 读未提交造成的脏读 是最低的隔离级别，其含义是允许一个事务读取另外一个事务没有提交的数据。未提交读是一种危险 的隔离级别，所以一般在我们实际的开发中应用不广，但是它的优点在于并发能力高，适合那些对数据 一致性没有要求而追求高并发的场景，它的最大坏处是出现脏读。让我们看看可能发生的脏读场景， 如表所示。   T3时刻，因为采用未提交读，所以事务2可以读取事务l未提交的库存数据为1,这里当它扣减 库存后则数据为0，然后它提交了事务，库存就变为了。，而事务l在TS时刻回滚事 务，因为第一类丢失更新已经被克服，所以它不会将库存回滚到2，那么最后的结果就变为了 0，这样就出现了错误。脏读一般是比较危险的隔离级别，在我们实际应用中采用得不多。 为了克服脏读的问题，数据库隔离级别还提供了读已提交（readcommited）的级别， 下面我们时论它。  1.3.2 读已提交 读已提交解决了读未提交造成的脏读问题，但读已提交依然造成了另外一个问题&amp;ndash;不可重复读 读已提交： 是指一个事务只能读取另外一个事务已经提交的数据，不能读取未提交的数据。   在T3时刻事务2读取库存的时候，因为事务l未提交事务，所以读出的库存为l，于是事务2 认为当前可扣减库存；在T4时刻，事务l己经提交事务，所以在TS时刻，它扣减库存的时候 就发现库存为0，于是就无法扣减库存了。这里的问题在于事务2之前认为可以扣减，而到扣 减那一步却发现已经不可以扣减，于是库存对于事务2而言是一个可变化的值，这样的现象 我们称为不可重复读，这就是读写提交的一个不足。为了克服这个不足，数据库的隔离级别 还提出了可重复读的隔离级别，它能够消除不可重读的问题。  1.3.3 可重复读  可以看到，事务2在T3时刻尝试读取库存，但是此时这个库存己经被事务1事先读取，所以这 个时候数据库就阻塞它的读取，直至事务1提交，事务2才能读取库存的值。此时己经是TS时 刻，而读取到的值为0，这时就已经无法扣减了，显然在读写提交中出现的不可重复读的场 景被消除了。但是这样也会引发新的问题的出现，这就是幻读。  下面演示造成幻读的实战  1.3.4 序列化 (串行化) 串行化（Serializable):是数据库最高的隔离级别，它会要求所有的SQL都会按照顺序执 行，这样就可以克服上述隔离级别出现的各种问题，所以它能够完全保证数据的一致性。 2.</description>
    </item>
    
    <item>
      <title>SpringBoot优点</title>
      <link>https://fyzn12.github.io/post/spring-boot/springboot-information/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/springboot-information/</guid>
      <description> 1. SpringBoot简介 1.1 SpringBoot的优点  创建独立的Spring应用程序
 嵌入Tomcat、Jetty或者Undertow，无序部署WAR文件
 允许通过Maven来根据需要获取starter； 尽可能自动部署Spring； 提供生产就绪功能，如指标、健康检查和外部配置； 绝对没有代码生成，对XMl没有要求配置。
  1.2 传统SpringMVC和SpringBoot的对比 1.2.1 SpringMVC的工作原理  1.2.2 两者的对比 在传统的SpringMVC项目开发中，开发一个简易的SpringMVC项目，需要配置DispatcherServlet, 也需要配置SpringIoC的容器。你可以选择使用web.xml的配置来实现，当然，如果你使用的是 Servlet 3.1规范，也可以继承由SpringMVC提供的 AbstractAnnotationConfigDispatcherServletlnitializer来配置SpringMVC项目。 </description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://fyzn12.github.io/post/design_mode/strategypattern/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/strategypattern/</guid>
      <description>1 OO設計原則 OO設計的五大原則  单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。
 开放封闭原则：实现开放封闭的核心思想就是对抽象编程，而不是对具体编程，因为抽象相对稳定。
 依赖倒置原则：依赖抽象，不要依赖具体。 里氏代换原则：子类型必须能够替换到他们的父类型。主要着眼于对抽象和多态简历在继承的基础上
 接口隔离原则：多个和客户相关的接口要好于一个通用接口
  2 设计模式————策略模式 2.1 策略模式原理 分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里放具体设定行为对象。 原则就是：分离变化部分，封装接口，基于接口编程实现各种功能。此模式让行为算法的变化独立于算法的使用者。 2.2 策略模式设计的代码分析————模拟鸭子项目 2.2.1 抽象出鸭子的行为，鸭子具有飞行能力和叫声，抽象出该接口 package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:42 * @description:会飞的鸭子 */ public interface FlyBehavior { void fly(); } package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:43 * @description:叫声 */ public interface QuackBehavior { void quack(); } 2.</description>
    </item>
    
    <item>
      <title>SpringCloud微服务网关技术Zuul</title>
      <link>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zuul%E7%BD%91%E5%85%B3/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zuul%E7%BD%91%E5%85%B3/</guid>
      <description>1 网关的简介 1.1 网关API（接口） Gateway（网关） 网关的概念：相当于客户端请求统一请求到网关服务器上，再由网关服务器进行转发请求到实际的服务器地址上， 类似于Nginx。 网关的作用：网关可以拦截客户端所有请求，对该请求进行权限控制、负载均衡、日志管理、接口调用监控等 网关和过滤器的区别：过滤器适合于单个tomcat服务器进行拦截请求，网关是拦截整个微服务所有请求。 网关分为内网网关和外网网关 Nginx和Zuul网关的区别： 1. Zuul和Nginx都可以实现负载均衡、反向代理、过滤请求、实现网关效果 2. 不同点 （1）Nginx采用C语言编写，Zuul采用java语言编写，Zuul的负载均衡实现是采用Ribbon + eureka实现本地负载均衡 （2）Nginx负载均衡实现采用服务器端实现负载均衡 （3）Nginx比Zuul功能更加强大，因为Nginx整合一些脚本语言（Nginx + Lua） （4）Nginx适合于服务器端负载均衡 （5）Zuul适合服务中实现网关，而且使用技术是java 最好建议nginx + zuul实现网关 nginx作用实现反向代理 zuul对微服务实现网关拦截  1.2 接口在什么背景下产生的 在面向服务架构和微服务背景下差生，目的是为了解耦。  1.3 接口分类  开放接口&amp;mdash;&amp;ndash;其他机构合作伙伴进行调用（必须在外网访问），如微信公众号开发，需要通过appid + appsocket 生成accessToken 进行通信。对接支付宝开发、微信开发；目的可以授权，遵循OAuth2.0协议方式
 内部接口
一般只能在局域网中进行访问，服务调用之间关系都在同一个微服务系统中 目的：保证安全问题   1.3.1 设计一套项目接口需要考虑的点 接口权限（开放接口|内部接口） 考虑幂等性 安全性（https）防止串改数据（验证签名） 使用网关拦截 接口实现黑名单和白名单、接口使用http协议 + json格式，符合restful风格，目的是为了跨平台。 考虑高并发对接口服务实现保护服务降级、熔断、隔离之类 最后使用统一的API管理平台  2 搭建一个Zuul网关系统 2.1 zuul网关搭建示意图  2.2 创建zuul网关项目，在parent中添加一下依赖 &amp;lt;!-- 导入springcloud整合zuul启动器 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>SpringCloud整合Zookeeper注册中心</title>
      <link>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid>
      <description>前言 
1 使用Zookeeper代替Eureka作为注册中心 1.1 Zookeeper简介 Zookeeper分布式协调工具，可以实现注册中心 Zookeeper节点类型：临时节点 1.3 Zookeeper安装与使用 1.3.1 windows下载Zookeeper 1. 下载与安装 博客详解（别人博客）
2. 修改zkServer.cmd配置文件  3. 下载Zookeeper的图形界面的管理工具ZooInspector工具，解压之后便可使用 4. 进入Zookeeper解压之后的目录，直到bin目录，在该目录输入cmd进入控制台  5. 在控制台运行zkServer.cmd便可开启Zookeeper服务  2 使用Zookeeper作为注册中心步骤 zookeeper作为注册中心与Eureka作为注册中心的区别在于Eureka需要编写一个服务的启动类，但Zookeeper不需要 Zookeeper只需要打开ZooInspector工具，连接服务即可（确保在cmd中运行zkServer.cmd）  2.1 创建会员服务 2.1.1 配置pom文件 &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.fyzn12&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springcloud-zk-member&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;springcloud-zk-member Maven Webapp&amp;lt;/name&amp;gt; &amp;lt;!-- FIXME change it to the project&amp;#39;s website --&amp;gt; &amp;lt;url&amp;gt;http://www.example.com&amp;lt;/url&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Hoxton.SR2&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>java基础底层</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</guid>
      <description>1 JVM的解析 1.1 JVM的结构图  大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区） ,Heap（堆） , Program Counter Register （程序计数器） , VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,Native Method Stack （ 本地方法栈 ） ，其中Method Area 和 Heap 是线程共享的 ，VM Stack，Native Method Stack 和Program Counter Register 是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。 首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件 （以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字 节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ 概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程， 就为其分配一个 Program Counter Register（程序计数器） , VM Stack（虚拟机栈）和Native Method Stack （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放 掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相 同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域 （实际上对大部分虚拟机来说知发生在Heap上）的原因。 1.</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>java多线程总结 多线程的几种实现方式  继承Thread类 重写run（）方法定义线程的行为；
如下图所示  实现Runnable接口
如下图所示
    实现 Callable 接口，该接口中的 call方法可以在线程执行结束时产生一个返回值。
使用总结：因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类就无法再继承其 他类了，显然使用 Runnable 接口更为灵活。
实现Runnable接口比继承Thread类所具有的优势：
1）：适合多个相同的程序代码的线程去处理同一个资源 2）：可以避免java中的单继承的限制 3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类 创建多线程的三种方式:两个接口（Runnable、Callable）一个类（Thread）  实例变量与线程安全 自定义线程类中的实例变量针对其他线程可以有共享与不共享之分。当每个线程都有各自的实例变量时，就是变量不共享。共享数据的情况就是多个线程可以访问同一个变量。 来看下面的示例：  打印的结果中存在多个线程同时对count进行操作，产生了&amp;#34;非线程安全&amp;#34;问题 * 在某些JVM中，i--的操作要分成如下3步： * 取得原有变量的值。计算i-1。对i进行赋值。 * 在这三个步骤中，如果有多个线程同时访问，那么一定会出现非线程安全问题。 解决方法就是使用 synchronized 同步关键字 使各个线程排队执行run()方法。修改后的run()方法：    synchronized 关键字的用法 在上面提到&amp;#34;同步&amp;#34;关键字，synchronized关键字可以将方法或者对象标记为同步，以实现对对象和法 的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将 synchronized 作为方法的修饰符。 如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另 一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数 据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方 法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效 率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。  线程的状态变化 要想实现多线程，必须在主线程中创建新的线程对象。任何线程一般具有5种状态，即创建，就绪，运行 阻塞，终止。下面分别介绍一下这几种状态：  创建状态</description>
    </item>
    
    <item>
      <title>Spring Boot整合Spring Data JPA</title>
      <link>https://fyzn12.github.io/post/spring-boot/spring-data/</link>
      <pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/spring-data/</guid>
      <description>Spring Boot整合Spring Data JPA 1 Spring Boot整合Spring Data JPA环境的搭建和测试 1.1 创建项目配置pom文件  Spring Boot整合Spring Data JPA时需要添加一下依赖包
&amp;lt;dependencies&amp;gt; &amp;lt;!-- 导入springboot的启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 导入mybatis的启动器 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 导入springboot整合spring Data JPA的启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- mysql数据库 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- mysql的连接池 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${druid.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 
 该项目需要有一个父工程，该工程打包方式以pom形式打包，整合了测试所需要的的依赖包。
  1.2 创建application.properties文件 注意：该文件这里主要配置数据库的连接，Jpa的一些属性  配置数据库的连接； 配置正向工程和sql语句的显示。</description>
    </item>
    
    <item>
      <title>redis之java客户端</title>
      <link>https://fyzn12.github.io/post/redis/jedis/</link>
      <pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/redis/jedis/</guid>
      <description>1 jedis的简单介绍 1.1 Jedis是什么 直观来说，jedis就是redis-cli   1.2 引入jedis的依赖包 &amp;lt;!-- 引入jedis的依赖包 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.3&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  1.3 jedis直连  生成一个Jedis对象，这个对象负责和指定Redis节点进行通信
Jedis jedis = new Jedis(&amp;ldquo;127.0.0.1&amp;rdquo;,6379);
 jedis执行set操作
jedis.set(&amp;ldquo;hello&amp;rdquo;,&amp;ldquo;world&amp;rdquo;);
 jedis执行get操作，value=&amp;ldquo;world&amp;rdquo;
String value = jedis.get(&amp;ldquo;hello&amp;rdquo;);
   Jedis构造函数的简单介绍 Jedis构造方法的参数 Jedis(String host,int port,int connectionTimeout,int soTimeout); host:Redis节点的所在机器的IP； port：Redis节点的端口； connectionTimeout：客户端连接超时； soTimeout：客户端读写超时；  1.4 Jedis直连和连接池的对比  2 redis的具体实现 2.1 慢查询  生命周期
 三个命令
 两个配置
 运维经验
  2.</description>
    </item>
    
    <item>
      <title>数据库易忘知识点总结</title>
      <link>https://fyzn12.github.io/post/database/database/</link>
      <pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/database/database/</guid>
      <description>数据库的基本知识点
 1 数据库的基本常用知识点 1.1 在创建数据库时，指定数据库编码命令 create database ads character set &amp;#39;utf8&amp;#39; 如图所示   1.2 对数据表的操作  删除数据
语法：
delete from 表名 [where 条件]
注意：
* 如果不加条件，则删除表中所有记录。
* 如果要删除所有记录
delete from 表名&amp;mdash;不推荐使用。有多少条记录就会执行多少次删除操作。
* TRUNCATE TABLE 表名；&amp;ndash;推荐使用，效率更高，先删除表，然后创建相同的表。
 update 表名 set 列名1 = 值1，列名2 = 值2，&amp;hellip;[where 条件]; 注意：如果不加条件，则会修改所有的记录；
 多表查询取出重复的行
关键字 distinct  DQL：查询语句
 排序查询
语法：order by 子句
排序方式： ASC：升序；DESC：降序
注意：如果有多个排序条件，则当前的条件值一样时，才会判断第二个条件。
 聚合函数：
（1）count：计算个数
（2）max
（3）min
（4）sum</description>
    </item>
    
    <item>
      <title>数据库易忘知识点总结</title>
      <link>https://fyzn12.github.io/post/database/%E5%AF%BC%E5%87%BA%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/database/%E5%AF%BC%E5%87%BA%E7%BB%93%E6%9E%84/</guid>
      <description>根据数据表，导出数据结构
 SELECT COLUMN_NAME 列名, COLUMN_TYPE 数据类型, DATA_TYPE 字段类型, CHARACTER_MAXIMUM_LENGTH 长度, IS_NULLABLE 是否为空, COLUMN_DEFAULT 默认值, COLUMN_COMMENT 备注 FROM INFORMATION_SCHEMA. COLUMNS WHERE &amp;ndash; super_express为数据库名称，到时候只需要修改成你要导出表结构的数据库即可 table_schema = &amp;lsquo;super_express&amp;rsquo; AND &amp;ndash; s_patient_list为表名，到时候换成你要导出的表的名称 &amp;ndash; 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称 table_name = &amp;lsquo;user&amp;rsquo;</description>
    </item>
    
    <item>
      <title>SpringCloud整合Hystrix服务保护框架</title>
      <link>https://fyzn12.github.io/post/springcloud/hystrix%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/hystrix%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E6%A1%86%E6%9E%B6/</guid>
      <description>1 引入Hystrix需要了解的知识点 1.1 服务的雪崩效应 服务的雪崩效应：默认情况下，tomcat只有一个线程池去处理所有客户端发生的所有请求，这样在高并发下的情况下， 如果客户端所有的请求堆积到同一个接口上（也就是客户端访问同一个接口），tomcat的所有线程去处理请求，可能 会导致其他服务接口无法访问。 假设tomcat最大请求数为20，客户端发送的请求数为100，会发生80个请求产生延迟等待  1.2 Hystrix服务保护框架能解决什么问题  断路器
 服务降级
 服务熔断
 服务隔离机制
 服务雪崩效应，连环雪崩效应
注意：如果雪崩效应严重的话，可能会造成整个服务崩溃   1.3 Hystrix解决雪崩效应的原理  服务降级 &amp;mdash;-友好提示
在高并发的情况下，防止用户一直等待，在tomcat中没有线程处理客户端发生的请求时，不应该让客户端一直在等待， 使用服务降级（返回一个友好的提示给客户端），目的是为了用户的体验，调用fallback本地方法  服务隔离 &amp;mdash;-线程池隔离和信号量隔离
信号量的使用示意图：当n个并发请求去调用一个目标服务接口时，都要获取一个信号量才能真正去调用 目标服务接口，但信号量有限，默认是10个，可以使用maxConcurrentRequests参数配置，如果并发请求数多于 信号量个数，就有线程需要进入队列排队，但排队队列也有上限，默认是 5，如果排队队列也满，则必定有请求线 程会走fallback流程，从而达到限流和防止雪崩的目的。 信号量模式从始至终都只有请求线程自身，是同步调用模式，不支持超时调用，不支持直接熔断，由于没有线程的 切换，开销非常小。 线程池的使用示意图如下图所示，当n个请求线程并发对某个接口请求调用时，会先从hystrix管理的线程池里面 获得一个线程，然后将参数传递给这个线程去执行真正调用。线程池的大小有限，默认是10个线程，可以使用 maxConcurrentRequests参数配置，如果并发请求数多于线程池线程个数，就有线程需要进入队列排队，但排队 队列也有上限，默认是 5，如果排队队列也满，则必定有请求线程会走fallback流程。 线程池模式可以支持异步调用，支持超时调用，支持直接熔断，存在线程切换，开销大。    服务熔断
服务熔断目的是为了保护服务，在高并发的情况下，如果请求达到一定得极限（可以设置阈值），如果流量超过 了这是的阈值，自动开启保护服务的功能，使用服务降级方式返回一个友好的提示。服务熔断和服务降级一起使用  2 搭建Hystrix服务保护框架 2.1 feign客户端超时设置 首先了解feign客户端默认超时时间是1秒 ribbon: # 建立连接所用的时间 ReadTimeout: 5000 # 建立之后读取所用的时间 ConnectTimeout: 5000  2.</description>
    </item>
    
    <item>
      <title>微服务架构的介绍</title>
      <link>https://fyzn12.github.io/post/springcloud/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 26 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</guid>
      <description>微服务架构的介绍 1 单体架构 单体架构也称为单体系统或者单体应用。就是一种把系统中的所有功能、模块耦合在一个应用中的架构方式  1.1 单体架构特点 1. 单体架构最终会打包成一个独立的单元(导成一个唯一的jar包或者war包) 2. 会以一个进程的方式来运行 3. 项目结构图如下图所示  
1.2 单体架构的优点、缺点 1.2.1 优点： 1. 项目易于管理 2. 部署简单  1.2.2 缺点： 1. 测试成本高 2. 可伸缩性差 3. 可靠性差 4. 迭代困难 5. 跨语言程度差 6. 团队协作难  2 微服务架构 2.1 什么是微服务 微服务就是一种架构风格，一个大型的复杂软件应用，由一个或多个微服务组成。 系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅仅关注于完成一件任务。  2.2 什么架构风格 架构风格就是项目的一种设计模式  2.2.1 常见的架构风格  客户端与服务端
 基于组件模型的架构（EJB） 分层架构（MVC） 面向服务架构（SOA）
  2.3 微服务的特点 1. 系统是由多个服务构成 2. 每个服务可以单独独立部署 3. 每个服务之间是松耦合的。服务内部是高内聚的，外部是低耦合的。高内聚就是每个服务只关注于完成一个功能  2.</description>
    </item>
    
    <item>
      <title>SpringCloud之Eureka2.0服务注册中心</title>
      <link>https://fyzn12.github.io/post/springcloud/springcloud-eureka/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/springcloud-eureka/</guid>
      <description>SpringCloud之Eureka2.0服务注册中心 1 了解相关概念 1.1 微服务架构如何拆分  微服务架构把每一个职责单一功能存放在独立的服务中
 每个服务运行在单独的进程中
 每个服务有自己独立数据库存储、实际上有自己独立的缓存、数据库、消息队列等
  1.2 微服务架构与SOA架构区别  微服务架构基于SOA架构演变过来，继承SOA架构优点，在微服务架构中去除SOA架构中的ESB消息总线，采用http+json（restful）进行传输。
 微服务架构比SOA架构粒度会更加精细，让专业的人去做专业的事。
 SOA架构中可能数据存储会发生共享，微服务架构强调每个服务都是单独的数据库，保证每个服务与服务之间互不影响。
  1.3 一线简单的概念 1.3.1 服务治理 服务治理： 阿里巴巴开源的Dubbo和当当网在基础上扩展的Dubbox，Eureka，Apache的Consul等 1.3.2 服务注册与发现 RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）  服务注册与服务发现原理，在任何的RPC远程调用框架中，都会有一个注册中心。
 注册中心的概念：存放服务地址相关信息（接口地址） SpringCloud中支持一下三种注册中心
Eureka Consul（go语言编写） Zookerper 注意：Dubbo支持两种Redis和Zookeeper     springcloud组件架构图

  2 SpringCloud支持的三种注册中心详解 2.1 Eureka注册中心环境搭建 2.1.1 配置基于单集群的环境 1. 配置pom文件 &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.fyzn12&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springcloud-study-server&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;springcloud-study-server Maven Webapp&amp;lt;/name&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>SpringCloud整合Consul注册中心</title>
      <link>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88consul%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88consul%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid>
      <description>SpringCloud整合Consul注册中心 1 Consul简介 Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更“一站式”，内置了服务注册与发现框 架、具有以下性质： 分布一致性协议实现、 健康检查、 Key/Value存储、 多数据中心方案， 不再需要依赖其他工具（比如ZooKeeper等）。 2 SpringCloud整合Consul 2.1 创建会员服务 2.1.1 配置会员服务的pom文件 &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.fyzn12&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springcloud-consul-member&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;springcloud-consul-member Maven Webapp&amp;lt;/name&amp;gt; &amp;lt;!-- FIXME change it to the project&amp;#39;s website --&amp;gt; &amp;lt;url&amp;gt;http://www.example.com&amp;lt;/url&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Hoxton.SR2&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- 导入springboot的启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 导入springcloud整合Zookeeper启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>java基础篇</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/</guid>
      <description>JVM加载class文件的原理机制 JVM中类的装载是由类加载器（ClassLoader）和他的子类来实现的，java中的类加载器是一个重要的 java运行时系统组件，他负责在运行时查找和装入类文件中的类。 JDK和JRE的区别 * JDK ：java development kit的简称，java开发的环境和运行环境 * JRE ：java runtime environment的简称，java运行环境。 * 具体来说JDK其实包含了jre，如下图所示  同时还包含了编译java远吗的编译器javac，还包含了很多java调试和分析的工具。
==和equals的区别 ==解读 对于基本类型和引用类型 == 的作用效果是不同的， * 基本类型：比较的是值是否相等 ； * 引用类型：比较的是引用是否相同； 如下代码 String x = &amp;#34;string&amp;#34;; String y = &amp;#34;string&amp;#34;; System.out.println(x==y); // true System.out.println(x==z); // false System.out.println(x.equals(y)); // true System.out.println(x.equals(z)); // true 因为x和y指向的是同一个“引用”，所以 == 是true，换句话说： == 是对引用类型作比较。 而new String（）方法则重新开辟了内存空间，所以 == 比较的是两个不同的引用，== 比较的结果则为false。 而equals比较的是 “值” ，所以结果都为true。  equals解读 equals的本质就是 ==，只不过String和Integer等重写了equals的方法，把他变成了 &amp;#34; 值 的 比 较 &amp;#34; equals的源码如下 public boolean equals（Object obj）{ return (this == obj); } 在没有重写equals方法时 equals就是==，他们比较的都是引用类型是否相等，而不是值是否相等； 如下代码可以很清晰的解释这一观点： class Cat { public Cat(String name) { this.</description>
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/jvm/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/jvm/</guid>
      <description>jvm初学篇
 1 JVM的启动流程  通过编辑器将java代码编辑好之后编译成java字节码，也就是.class文件；
 装载JVM 会通过当前路径或者系统的版本去寻找 JVM.cfg文件； 通过JVM.cfg文件寻找到 JVM.dll文件 &amp;mdash;该文件是JVM的具体实现；
 初始化本地接口 JNI &amp;mdash;如Env接口 JNI接口的作用就是负责将.class文件装载到JVM中；
 找到main方法并执行
   2 JVM的内存分区  1 PC寄存器  &amp;mdash; 每个线程拥有一个PC寄存器
 &amp;mdash; 在线程创建时 创建（PC寄存器）
 &amp;mdash; 指向下一条指令的地址
 &amp;mdash; 执行本地方法时，PC的值为undefined（未定义）  2 方法区  &amp;mdash; 保存装载的类信息
 类型的常量池 &amp;mdash;&amp;ndash; 这一点得注意 ： 在JDK6时，String等常量信息是保存在方法区，但是在JDK7时，已经移到了堆； 字段、方法信息
 方法字节码
  &amp;mdash; 线程共享
 &amp;mdash; 通常和永久区（Perm：保存一些相对来说静止稳定的数据）关联在一起
  3 Java堆  &amp;mdash; 和程序开发密切相关</description>
    </item>
    
    <item>
      <title>redis基础知识</title>
      <link>https://fyzn12.github.io/post/redis/redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/redis/redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <description>1 Redis的简介 1.1 了解什么是redis redis是一个开源的使用ANSI c语言编写、遵循BSA协议、支持网络、可基于内存亦可持久化的日志型、key-value数据库， 并提供多种语言的API。 他通常被称为数据结构服务器，因为值value可以是String、哈希（hash）、列表（list）、集合（sets）、和有序集合（sorted sets）等类型。  1.2 redis的特点 * Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 * Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 * Redis支持数据的备份，即master-slave模式的数据备份。  1.3 redis的优势 * 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 * 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 * 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务， 即原子性，通过MULTI和EXEC指令包起来。 * 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。  1.4 Redis支持的数据类型 * string（字符串） * hash（哈希） * list（列表） * set（集合） * zset或sorted set（有序集合）  2 Redis 命令 2.</description>
    </item>
    
    <item>
      <title>几种结构</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>  数据结构的分析
 1 队列 队列采用先进先出策略的集合类型，如图所示
1.1 队列的入队演示 如图将 89 添加到队列中，采用的是 ： 在队列队尾添加，整个事件时间复杂度为O(1)  1.2 队列的出队演示 当队列收到出队的命令后，会将指针指向head，从而移除head的值，原先head值指向的下一个值变为head，整个事件时间复杂度为 O(1)  注意：java中还有先进先出队列，策略和基本队列相反，和下面的栈的策略相同 1.3 队列的总结，队列是采用先进先出的策略，添加元素时是在队尾添加，出队时是在队头移除或出队 2 链表 2.1 链表插入策略的演示 2.1.1 头插  2.1.2 尾插  2.1.3 中间任意部位插入 任意部位的插入首先要指定一个插入点，在插入过程中会先遍历插入点前面的元素，找到插入点元素 之后在修改插入点元素的指针，让其指向新增元素   3 栈 栈（stack）是操作受限的线性表，限定元素的插入和删除运算只能在表的一端进行，通常把进行插入删除的一端称作栈顶（top） 另一端称为栈底（bottom）  3.1 栈的五种运算  置空栈setnull（s）：将栈s设置成空栈，即不管栈的原来状态如何一律置为空栈；
 判断栈是否为空empty(s):返回一个布尔值，当栈为空时返回1，否则返回返回0；
 进栈push(s,x):把元素x压入栈s中，成为新的栈顶元素；
 出栈pop(s):该操作从栈顶弹出栈顶元素并返回，栈为空时返回NULL；
 读栈顶元素gettop(s):返回栈顶元素，该操作栈的状态不变；   栈与队列的总结 栈可以形象的比喻为一个瓶子，先进的元素只能从瓶口进，然后往瓶底走，出的时候也只能从瓶口出，而后面进的元素往往先出 队列可以看成一条管道，该管道从bottom入，top出 </description>
    </item>
    
    <item>
      <title>常见算法篇</title>
      <link>https://fyzn12.github.io/post/algorithm/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
      <description>常见算法总结篇 递归算法 递归算法有一下几个特点 * 递归算法必须设定循环终止条件，称为递归出口 * 方法里调用自身 如下面两个例子： 1. 一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。 例：n=1237 函数设定如下： //编写递归函数 private static void getNUm(int n){ //设置递归终止条件 System.out.printl(n); if（n&amp;lt;=5000）{ //调用自身 getNum(n*2); System.out.printl(n); } } 2. 第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？ 程序设定如下 //n代表传入的人的数量 private static int getAge(int n){ //设定递归终止条件 if（n==1） return 10; //调用自身并返回； return getAge(n-1)+2; } 排序算法  快速排序算法 排序步骤总结如下：
* 从数组中挑出一个元素，称为“基准”（pivot）； * 重新排序数组，所有元素比基准值小的摆放在基准前面，所有元素比基准大的摆放在基准的后面 （相同可以任意放一边）。这个分割之后，该基准就是他的最后的位置，这个称为“分割”操作 * 递归地把小于基准值元素的子数组和大于基准元素的子数组排序。 下面看一个列子： 请用快速排序排序下面的数组内的数字：String[] strVoid=new String[]{&amp;#34;11&amp;#34;,&amp;#34;66&amp;#34;,&amp;#34;22&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;55&amp;#34;,&amp;#34;22&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;32&amp;#34;}; 代码设计如下：严格按照上面三个步骤设计 //三个参数，排序的数组，排序左基点，排序右基点 private static void quickSort(String[] strViod,int left,int right){ //先判断左右指针是否越界 if (left&amp;gt;right){ returen; } //定义基准位置，左右移动时的指针以及中间变量 String standard,tmp; //步骤一：确定基准位置（可以随意） standard = strViod[left]; int i,j; i = left; j = right; //步骤二：初步与基准值比较，确认基准值的左右集合 while(i&amp;lt;j){ //首先进行基准值右侧值的判断,这里建议将String转为int进行判断，别用compareTo进行判断 while(Integer.</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://fyzn12.github.io/post/algorithm/selectionsorted/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/selectionsorted/</guid>
      <description>排序算法的简单介绍
 1 选择排序 1.1 选择排序的理解 选择排序（Selection sort）是一种简单直观的排序算法。 它的工作原理是： 第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置， 然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序 的数据元素的个数为零。选择排序是不稳定的排序方法。  1.2 选择排序的实现 /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/14 18:41 * @description:选择排序 */ public class SelectionSort { public static void sort(Comparable[] a) { int N = a.length; //将a[]按升序排序  for (int i = 0; i &amp;lt; N; i++) { int min = i; for (int j = i+1;j&amp;lt;N;j++){ if (less(a[j],a[min])){ min = j; } } exch(a,i,min); } } private static boolean less(Comparable v,Comparable w){ return v.</description>
    </item>
    
    <item>
      <title>认真刷面试题的第一天</title>
      <link>https://fyzn12.github.io/post/faceword/firstday/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/faceword/firstday/</guid>
      <description>牛客网的第一天
 1 关于java的异常处理机制：当某个线程抛出OutOfmemberError时，其他线程有可能不收影响 2 关于运算的理解  与运算（&amp;amp;）
进行运算的两个数据，按二进制位进行“与”运算。 规则：0&amp;amp;0=0; 0&amp;amp;1=0; 1&amp;amp;0=0; 1&amp;amp;1=1; 即： 两位同时为“1”，结果才为“1”，否则为0  或运算（|）
进行运算的两个数据，按二进制位进行“或”运算。 运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1； 即 ：参加运算的两个对象只要有一个为1，其值为1。  非运算：~
1取0，0取1 ~1 = 0, ~0 = 1 ~(10001) = 01110  异或运算（^）
参加运算的两个数据，按二进制位进行&amp;#34;异或&amp;#34;运算 参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 考点：交换两个变量的值（不借助第三个变量） 使用异或运算符： 例：a=6,b=5 核心代码： a = a ^ b; b = a ^ b; a = a ^ b;   经过上面的介绍下面这些运算应该就能理解了java中的 |= 、&amp;amp;= 、^= 运算符的理解
3 filesort 并不是磁盘文件进行排序，只是进行了一个排序操作，但是查询次数过多确实会对性能造成影响 4 在java中是不能强制垃圾回收器立即执行的，system.</description>
    </item>
    
    <item>
      <title>SpringBoot提供的五种异常机制</title>
      <link>https://fyzn12.github.io/post/spring-boot/springboot-exception/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/springboot-exception/</guid>
      <description>SpringBoot中的异常处理方式  自定义错误页面
 @ExceptionHandle注解处理异常
 @ControllerAdvice + @ExceptionHandle注解处理异常
 配置SimpleMappingExceptionResolver处理异常
 自定义HandleExceptionResolver类处理异常
  1 自定义错误页面 1.1 SpringBoot的默认异常机制详解 SpringBoot默认的异常机制：SpringBoot默认已经提供了一套处理异常的机制。 一旦程序中出现了异常，SpringBoot会向/error的url发送请求。在SpringBoot中提供了一个 叫BasicExceptionController来处理/error请求，然后跳转到默认显示的页面来展示异常信息。   1.2 自定义错误界面 如果我们需要将所有的异常统一跳转到自定义错误页面，需要在classpath下创建一个templates目录(即在resources目录下创建templates目录)，在该目录下创建一个名为error.html的页面。 2 基于@ExceptionHandler注解处理异常 2.1 创建指定处理的异常 /** *java.lang.ArithmeticException *该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 *参数Exceptione:会将产生异常对象注入到方法中 */ @ExceptionHandler(value={java.lang.ArithmeticException.class}) publicModelAndViewarithmeticExceptionHandler(Exceptione){ ModelAndViewmv=newModelAndView(); mv.addObject(&amp;#34;error&amp;#34;,e.toString()); mv.setViewName(&amp;#34;error1&amp;#34;); returnmv; } /** *java.lang.NullPointerException *该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 *参数Exceptione:会将产生异常对象注入到方法中 **/ @ExceptionHandler(value={java.lang.NullPointerException.class}) publicModelAndViewnullPointerExceptionHandler(Exceptione){ ModelAndViewmv=newModelAndView(); mv.addObject(&amp;#34;error&amp;#34;,e.toString()); mv.setViewName(&amp;#34;error2&amp;#34;); return mv； }  2.2 使用该方法的总结 使用@ExceptionHandler注解处理异常时，首先编写异常页面error.html，其次创建Controller类，编写基于注解@ExceptionHandle注解的方法，并且在该方法中必须指定想要助理异常的名称如上面的java.lang.NullPointerException.class、java.lang.ArithmeticException.class。 3 使用@ControllerAdvice + @ExceptionHandler注解处理异常 3.1 创建一个全局异常类使用ControllerAdvice注解 /** *全局异常处理类 **/ @ControllerAdvice public class GlobalException { /** * java.</description>
    </item>
    
    <item>
      <title>mybatis之动态SQL</title>
      <link>https://fyzn12.github.io/post/mybatis/dynamicsql/</link>
      <pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/mybatis/dynamicsql/</guid>
      <description>动态SQL语句总结 主要内容  if元素
 choose、when、otherwise元素 trim、where、set元素 foreach元素  if 元素 下面先看一个例子
&amp;lt;select id=&amp;#34;selectUserById&amp;#34; resultType=&amp;#34;MyUser&amp;#34; parameterType=&amp;#34;MyUser&amp;#34;&amp;gt; select * from user where 1=1 &amp;lt;if test =&amp;#34;name !=null and name !=&amp;#39;&amp;#39;&amp;#34;&amp;gt; and name like concat(&amp;#39;%&amp;#39;,#{name},&amp;#39;%&amp;#39;) &amp;lt;/if&amp;gt; &amp;lt;if test = &amp;#34;sex !=null and sex !=&amp;#39;&amp;#39;&amp;#34;&amp;gt; and sex = #{sex} &amp;lt;/if&amp;gt; &amp;lt;/select&amp;gt;  在上面的例子中，运用的是sql语句的拼接，在这里需要注意的是有如下几点：
1. resultType与resultMap不能同时使用 2. #{xxx}与${vlaue}的使用看上一篇博客 3. if的判断条件的test里面的参数目前我知道有三种声明方式如下： 1）对象作为参数，则test里面的参数为对象的属性 2)@Param声明的参数 3)map方式键值对  choose、when 、otherwise元素 有些时候不想用到所以的条件语句，而只想从中选择一二，针对这种情况，Mybatis提供了&amp;lt;choose&amp;gt;元素，如下例子。
&amp;lt;select id = &amp;#34;selectUserBychoose&amp;#34; resultType=&amp;#34;MyUser&amp;#34; parameterType=&amp;#34;MyUser&amp;#34;&amp;gt; select * from user where 1=1 &amp;lt;choose&amp;gt; &amp;lt;when test=&amp;#34;name !</description>
    </item>
    
    <item>
      <title>ssm随学札记</title>
      <link>https://fyzn12.github.io/post/ssm/ssm%E9%9A%8F%E5%AD%A6%E6%9C%AD%E8%AE%B0/</link>
      <pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/ssm/ssm%E9%9A%8F%E5%AD%A6%E6%9C%AD%E8%AE%B0/</guid>
      <description>使用在使用ObjectMapper将json转对象，调用mapper.readValue(jsonStr, XwjUser.class)时，报如下错：
java.lang.NullPointerException at com.fasterxml.jackson.core.JsonFactory.createParser(JsonFactory.java:889) at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3004) at com.express.utils.JsonUtils.jsonToPojo(JsonUtils.java:48) at com.express.web.controller.backstage.ManagerBaseController.getCurrentUser(ManagerBaseController.java:29) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.method.annotation.ModelFactory.invokeModelAttributeMethods(ModelFactory.java:142) at org.springframework.web.method.annotation.ModelFactory.initModel(ModelFactory.java:111) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:872) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942)  这个错误产生的原因有三个：
1. 是因为在使用ObjectMapper将json转为对象时，会默认调用该对象的无参构造函数，因此在该对象类中加入无参构造函数即可去掉该错误。
2. 期待转成的对象与json对应的属性不匹配。
3. 真正的空指针，既json为空。
ajax提交的几个坑  通过ajax提交数据，在后台是无法进行重定向的，只能通过前端进行重定向。具体如何实现如下：
* 判断满足需要重定向时，需要修改返回前端的Header以及Status，并设置拦截（当然这个可以不用）。
* 编写redirectUtil工具类,处理后台跳转，这里需要注意，设置 response.setStatus(HttpServletResponse.SC_FORBIDDEN);之后前端会被拦截，报403错误，代表服务端终止，前端进行操作。
/** *@author fyzn12 *@version 1.0 *@date 2020/4/18 13:46 *主要作用于ajax请求，后台重定向 *提供日志接口 *提供获取具体日志对象的方法 */ @Slf4j public class RedirecUtil { public static void redirect(HttpServletRequest request,HttpServletResponse response,String redirectUrl){ try { /* *如果是ajax请求 **/ String ajax = &amp;#34;XMLHttpRequest&amp;#34;; String header = &amp;#34;X-Requested-With&amp;#34;; if(ajax.</description>
    </item>
    
    <item>
      <title>Mybatis-的配置文件</title>
      <link>https://fyzn12.github.io/post/mybatis/mybatis01/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/mybatis/mybatis01/</guid>
      <description>Mybatis的配置文件以及mapper文件 在mybatis的配置文件中，所有的配置均是在 &amp;lt;configuration&amp;gt;&amp;lt;/configuration&amp;gt;`这对标签里配置。在这里记录一些课堂老师讲解的重要配置。  &amp;lt;configuration&amp;gt; 1.配置日志（开启日志）通过```&amp;lt;settings&amp;gt;&amp;lt;/settings&amp;gt;```标签配置，如下所示： &amp;lt;!-- 开启日志 --&amp;gt; &amp;lt;settings&amp;gt; &amp;lt;setting name=&amp;#34;logImpl&amp;#34; value=&amp;#34;LOG4J&amp;#34;/&amp;gt; &amp;lt;/settings&amp;gt; 2.为了提高效率，在mapper文件不用每个resultType属性里都添加包名，设置别名。设置在typeAliases标签里，如下两种方式配置，优点和缺点 &amp;lt;typeAliases&amp;gt; &amp;lt;typeAlia type=&amp;#34;com.pojo.Student&amp;#34;alias=&amp;#34;Student&amp;#34;/&amp;gt;--方法一 缺点：有多少个类，就得有多少行这个代码 &amp;lt;!-- 或者&amp;lt;package name=&amp;#34;com.pojo/&amp;gt;&amp;#34; --方法二 缺点： 在pojo包下如果还有子包，在子包下有与子包同级的类名相同时，会出现歧义，不知指定的是哪个包。 &amp;lt;/typeAliases&amp;gt; 3.数据库连接的配置
&amp;lt;environments default=&amp;#34;default&amp;#34;&amp;gt; &amp;lt;!--配置多个数据源,但只能指定一个使用 --&amp;gt; &amp;lt;!-- Mysql的数据库链接 --&amp;gt; &amp;lt;environment id=&amp;#34;default&amp;#34;&amp;gt; &amp;lt;transactionManager type=&amp;#34;JDBC&amp;#34;/&amp;gt;&amp;lt;!-- 指定当前数据库的事务管理方式 --&amp;gt; &amp;lt;dataSource type=&amp;#34;POOLED&amp;#34;&amp;gt;&amp;lt;!-- 数据源的管理方式为连接池 --&amp;gt; &amp;lt;property name=&amp;#34;driver&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;dbc:mysql://localhost:3306/ssmLab4046?serverTimezone=GMT%2B8&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;1234&amp;#34;/&amp;gt; &amp;lt;!-- 设定数据库的链接4要素 --&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt;  4.映射文件的扫面通过标签配置。
&amp;lt;!-- 一定是文件格式--&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;#34;com/mapper/StudentMapper.xml&amp;#34;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;mapper&amp;gt;&amp;lt;/mapper&amp;gt;  mapper文件配置以及对应方法的讲解  mapper配置时设置的属性namespace定义一个操作包，是映射文件匹配的重要点；</description>
    </item>
    
    <item>
      <title>mybatis之mapper接口编程</title>
      <link>https://fyzn12.github.io/post/mybatis/mapper%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/mybatis/mapper%E7%BC%96%E7%A8%8B/</guid>
      <description>面向接口编程的思路  创建pojo（javaBean）类
 创建接口
 创建接口对应的mapper文件
注意：
1）mapper文件名必须和接口名相同，如接口名为ITeacher则mapper名为ITeacher（并且在同一个包下，实践得到）,如果使用扫描包的方式，那么两者必须在同一个包下，如
 
  如果用读取文件的方式，则不用在同一个包下如下
&amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;#34;mapper/*.xml&amp;#34;/&amp;gt; &amp;lt;/mappers&amp;gt; 2）mapper文件的namespace取值必须和接口的全路径相同
3）mapper中的SQL声明的id必须和接口中的方法名相同，如接口中声明方法seleteAll则sql的id必须为seleteAll
4）多参传递可以不写parameterType属性
5）参数的下标书写 &amp;lt;selete * from teacher where name=#{0} and age=#{1}表示方法中传的参数的第一个参数和第二个参数
6）参数的占位书写
7）参数的声明书写 方法中用@Param声明。
4. 读取mybatis-config.xml文件获取数据库的连接，以及读取mapper文件，得到InputStream对象，创建SqlSessionFactory对象，利用SqlSessionFactory对象建立session连接通过openSession（）方法
InputStream is; try { //1.利用org.apache.ibatis.io.Resources方法读取mybatis-config.xml is = Resources.getResourceAsStream(&amp;#34;mybatis-config.xml&amp;#34;); // 2.通过文件流,创建一个sqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder() .build(is); // 3.通过工厂创建一个数据库的连接session session = factory.openSession(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } &amp;emsp;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/</guid>
      <description>1 并发的原理解析 1.1 并发会造成什么问题  死锁
 资源占用 线程安全
&amp;hellip;
  1.2 并发的根本问题  原子性
 可见性
 有序性
  以上三个是造成线程安全的主要原因
1.2.1 线程在那里创建的 线程在CPU上开启和执行
在硬件上面CPU的缓存一致性即可见性 单核CPU没有可见性 在硬件上解决缓存一致性伊利诺斯协议&amp;ndash;MESI
1.2.2 java直接跟硬件交互的是什么 java直接跟硬件交互的是JVM
关键值在反射的标识是二进制
java中8个高级指令 lock unlock &amp;hellip;.
1.2.3 volatile解决可见性的原理，当然他也解决了有序性 需要了解指令重排序，指令流 数据量 控制流
volatile解决不了原子性</description>
    </item>
    
  </channel>
</rss>