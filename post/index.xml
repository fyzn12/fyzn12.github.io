<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on fyzn12</title>
    <link>https://fyzn12.github.io/post/</link>
    <description>Recent content in Posts on fyzn12</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 18 Jun 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://fyzn12.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>FileBeat</title>
      <link>https://fyzn12.github.io/post/elk/filebeat/</link>
      <pubDate>Fri, 18 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/elk/filebeat/</guid>
      <description>一、 filebeat简单理解 1.1、filebeat和beats的关系  首先filebeat是Beats中的一员。 Beats在是一个轻量级日志采集器，其实Beats家族有6个成员，早期的ELK架构中使用Logstash收集、解析日志，但是Logstash对内存、cpu、io等资源消耗比较高。相比Logstash，Beats所占系统的CPU和内存几乎可以忽略不计。 目前Beats包含六种工具：
 Packetbeat：网络数据（收集网络流量数据） Metricbeat：指标（收集系统、进程和文件系统级别的CPU和内存使用情况等数据） Filebeat：日志文件（收集文件数据） Winlogbeat：windows事件日志（收集Windows事件日志数据） Auditbeat：审计数据（收集审计日志） Heartbeat：运行时间监控（收集系统运行时的数据） 1.2、filebeat是什么  　Filebeat是用于转发和集中日志数据的轻量级传送工具。Filebeat监视您指定的日志文件或位置，收集日志事件，并将它们转发到Elasticsearch或 Logstash进行索引。
　Filebeat的工作方式如下：启动Filebeat时，它将启动一个或多个输入，这些输入将在为日志数据指定的位置中查找。对于Filebeat所找到的每个日志，Filebeat都会启动收集器。每个收集器都读取单个日志以获取新内容，并将新日志数据发送到libbeat，libbeat将聚集事件，并将聚集的数据发送到为Filebeat配置的输出。
 1.3、filebeat和logstash的关系  　因为logstash是jvm跑的，资源消耗比较大，所以后来作者又用golang写了一个功能较少但是资源消耗也小的轻量级的logstash-forwarder。不过作者只是一个人，加入http://elastic.co公司以后，因为es公司本身还收购了另一个开源项目packetbeat，而这个项目专门就是用golang的，有整个团队，所以es公司干脆把logstash-forwarder的开发工作也合并到同一个golang团队来搞，于是新的项目就叫filebeat了。
 二、filebeat原理是什么 2.1、filebeat的构成  　filebeat结构：由两个组件构成，分别是inputs（输入）和harvesters（收集器），这些组件一起工作来跟踪文件并将事件数据发送到您指定的输出，harvester负责读取单个文件的内容。harvester逐行读取每个文件，并将内容发送到输出。为每个文件启动一个harvester。harvester负责打开和关闭文件，这意味着文件描述符在harvester运行时保持打开状态。如果在收集文件时删除或重命名文件，Filebeat将继续读取该文件。这样做的副作用是，磁盘上的空间一直保留到harvester关闭。默认情况下，Filebeat保持文件打开，直到达到close_inactive
关闭harvester可以会产生的结果：
 文件处理程序关闭，如果harvester仍在读取文件时被删除，则释放底层资源。 只有在scan_frequency结束之后，才会再次启动文件的收集。 如果该文件在harvester关闭时被移动或删除，该文件的收集将不会继续  　一个input负责管理harvesters和寻找所有来源读取。如果input类型是log，则input将查找驱动器上与定义的路径匹配的所有文件，并为每个文件启动一个harvester。每个input在它自己的Go进程中运行，Filebeat当前支持多种输入类型。每个输入类型可以定义多次。日志输入检查每个文件，以查看是否需要启动harvester、是否已经在运行harvester或是否可以忽略该文件
 2.2、filebeat如何保存文件的状态  Filebeat保留每个文件的状态，并经常将状态刷新到磁盘中的注册表文件中。该状态用于记住harvester读取的最后一个偏移量，并确保发送所有日志行。如果无法访问输出（如Elasticsearch或Logstash），Filebeat将跟踪最后发送的行，并在输出再次可用时继续读取文件。当Filebeat运行时，每个输入的状态信息也保存在内存中。当Filebeat重新启动时，来自注册表文件的数据用于重建状态，Filebeat在最后一个已知位置继续每个harvester。对于每个输入，Filebeat都会保留它找到的每个文件的状态。由于文件可以重命名或移动，文件名和路径不足以标识文件。对于每个文件，Filebeat存储唯一的标识符，以检测文件是否以前被捕获。
2.3、filebeat何如保证至少一次数据消费 　Filebeat保证事件将至少传递到配置的输出一次，并且不会丢失数据。是因为它将每个事件的传递状态存储在注册表文件中。在已定义的输出被阻止且未确认所有事件的情况下，Filebeat将继续尝试发送事件，直到输出确认已接收到事件为止。如果Filebeat在发送事件的过程中关闭，它不会等待输出确认所有事件后再关闭。当Filebeat重新启动时，将再次将Filebeat关闭前未确认的所有事件发送到输出。这样可以确保每个事件至少发送一次，但最终可能会有重复的事件发送到输出。通过设置shutdown_timeout选项，可以将Filebeat配置为在关机前等待特定时间。
 本文来源于： FileBeat</description>
    </item>
    
    <item>
      <title>Redis结合kafka实现高并发抢单</title>
      <link>https://fyzn12.github.io/post/spring-boot/redis%E9%99%90%E6%B5%81%E7%BB%93%E5%90%88kafka%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%8A%A2%E5%8D%95/</link>
      <pubDate>Fri, 18 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/redis%E9%99%90%E6%B5%81%E7%BB%93%E5%90%88kafka%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%8A%A2%E5%8D%95/</guid>
      <description>实现环境：kafka、redis、mysql8 使用Spring Boot搭建环境，数据库采用乐观锁
 缓存和数据一致性分析  缓存和 DB 的一致性是一个讨论很多的问题，推荐看参考中的 使用缓存的正确姿势，首先看下先更新数据库，再更新缓存策略， 假设 A、B 两个线程，A 成功更新数据，在要更新缓存时，A 的时间片用完了，B 更新了数据库接着更新了缓存，这是 CPU 再分配给 A，则 A 又更新了缓存，这种情况下缓存中就是脏数据.
那么，如果避免这个问题呢？就是缓存不做更新，仅做删除，先更新数据库再删除缓存。
对于上面的问题，A 更新了数据库，还没来得及删除缓存，B 又更新了数据库，接着删除了缓存，然后 A 删除了缓存， 这样只有下次缓存未命中时，才会从数据库中重建缓存，避免了脏数据。 但是，也会有极端情况出现脏数据， A 做查询操作，没有命中缓存，从数据库中查询，但是还没来得及更新缓存，B 就更新了数据库，接着删除了缓存，然后 A 又重建了缓存，这时 A 中的就是脏数据，但是这种极端情况需要数据库的写操作前进入数据库，又晚于写操作删除缓存来更新缓存，发生的概率极其小，不过为了避免这种情况，可以为缓存设置过期时间。
 高并发控制实现 1.Redis的限流控制  根据前面的优化分析，假设现在有 10 个商品，有 1000 个并发秒杀请求，最终只有 10 个订单会成功创建，也就是说有 990 的请求是无效的，这些无效的请求也会给数据库带来压力，因此可以在在请求落到数据库之前就将无效的请求过滤掉，将并发控制在一个可控的范围，这样落到数据库的压力就小很多
由于计数限流实现起来比较简单，因此采用计数限流，限流的实现可以直接使用 Guava 的 RateLimit 方法，但是由于后续需要将实例通过 Nginx 实现负载均衡，这里选用 Redis 实现分布式限流
在 RedisPool 中对 Jedis 线程池进行了简单的封装，封装了初始化和关闭方法，同时在 RedisPoolUtil 中对 Jedis 常用 API 进行简单封装，每个方法调用完毕则关闭 Jedis 连接。</description>
    </item>
    
    <item>
      <title>SpringBoot使用@ComponentScan的Controller失效原因分析 </title>
      <link>https://fyzn12.github.io/post/spring-boot/componentscan%E6%B3%A8%E8%A7%A3%E5%AF%BC%E8%87%B4controller%E5%A4%B1%E6%95%88/</link>
      <pubDate>Fri, 18 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/componentscan%E6%B3%A8%E8%A7%A3%E5%AF%BC%E8%87%B4controller%E5%A4%B1%E6%95%88/</guid>
      <description>SpringBoot使用@ComponentScan的Controller失效原因分析  环境背景 在搭建整个架构过程中，启动类正常放在controller包外 启动类的注解如下：
@SpringBootApplication @Slf4j @EnableTransactionManagement @EnableKafka @ComponentScan(&amp;#34;com.seconds.dao&amp;#34;) public class SecondsApplication { public static void main(String[] args) { SpringApplication.run(SecondsApplication.class, args); } } 造成项目启动后，controller包下的路径无法访问 @ComponentScan 默认扫描使用该注解的类所在的包,包括这个包下的类和子包, 所以如果没有配置basepackages,并且类都放在子包中,是可以正常访问的 * 如果配置了@ComponentScn中的basepackages,那么就要把所有需要扫描的包都配置. * 这种情况下,@ComponentScan是不会再去扫描当前类所在的包的. * 之前我之所以以为@ComponentScan对启动类之外的包无能为力, * 这里没有配置controller类的包,导致程序无法访问. * 这里必须配置扫描当前启动类的包，不然当前启动类对应的控制器将失效 修改成一下:
@SpringBootApplication @Slf4j @EnableTransactionManagement @EnableKafka //@ComponentScan(&amp;#34;com.seconds&amp;#34;) @MapperScan(annotationClass = Repository.class, basePackages = &amp;#34;com.seconds.dao&amp;#34;) public class SecondsApplication { public static void main(String[] args) { SpringApplication.run(SecondsApplication.class, args); } } //或者将当前的controller包也扫描到注解中  @SpringBootApplication @MapperScan(annotationClass = Repository.</description>
    </item>
    
    <item>
      <title>mysql的存储引擎</title>
      <link>https://fyzn12.github.io/post/database/mysql%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/database/mysql%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description> 1 mysql支持Innodb存储引擎（支持行锁）  1.1 Innodb存储引擎概述 ① Innodb存储引擎：主要面向在线事务处理（OLTP）方面的应用。特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认情况下读取操作不会产生锁。
② InnoDB通过多版本并发控制（MVCC）来获取高并发，并实现了SQL标准的4种隔离级别，默认是repeatable级别。
③ 使用next-key locking（临键锁）的策略来避免幻读，准确来说是临键锁加间隙锁的策略避免幻读。 这也就是为什么下面提到的非唯一索引字段数据库使用行级锁却锁定的是多行，这与间隙锁有关
④ Innodb存储引擎的行锁是通过给索引项加锁实现，这一点musql和oracle不同，后者是通过在数据库中给对应的数据行加锁实现。
⑤ Innodb存储引擎这种行级锁决定，只有通过索引条件来检查数据，才能使用行级锁，否则将直接用表级锁。
 特别注意：使用行级锁一定要使用索引；查询非唯一索引字段数据库使用行级锁锁定多行，这个与数据库的  1.2 Innodb存储引擎内存 组成：缓冲池（buffer pool）、重做日志缓冲池（redo log buffer）以及额外的内存池（additional memory pool），分别由配置文件中的参数innodb_buffer_pool_size和innodb_log_buffer_size大大小决定。
缓冲池是占最大块内存的部分，用来存放各种数据的缓存。
Innodb存储引擎的工作方式：将数据库文件按页（每页16K）读取到缓冲池，然后按最近最久未使用（LRU）的算法来保留在缓冲池中的缓存数据。如果数据库文件需要修改，总是首先修改在缓存池中的页（发生修改后，该页即为脏页），然后再按照一定的频率将缓冲池的脏页刷新（flush）到文件。可以通过命令：show engine innodb status来查看innodb_buffer_pool的具体情况。
1.3 master thread innoDB存储引擎的主要工作都是在一个单独的后台线程master thread中完成。
master thread 的线程优先级别最高。其内部由几个循环（loop）组成：主循环、后台循环、刷新循环、暂停循环。
 2 MyISAM存储引擎  MyISAM存储引擎是mysql官方提供的存储引擎。其特点是不支持事务、表锁和全文索引，对于一些OLAP（在线分析处理）操作速度快。
MyISAM存储引擎表有MYD和MYI组成，MYD用来存储数据文件，MYI用来存放索引文件。
 </description>
    </item>
    
    <item>
      <title>SynchronizedMap如何让HashMap具备线程安全</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/synchronizedmap%E5%A6%82%E4%BD%95%E8%AE%A9hashmap%E5%85%B7%E5%A4%87%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/synchronizedmap%E5%A6%82%E4%BD%95%E8%AE%A9hashmap%E5%85%B7%E5%A4%87%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid>
      <description>问题：SynchronizedMap如何让HashMap具备线程安全  1. 首先利用SynchronizedMap的构造函数获取map的对象，而该构造器可以传入一个HashMap的集合作为参数 2. SynchronizedMap底层通过一个互斥信号量mutex（final Object） 进行方法同步的限定， synchronized（mutex）进行加锁，达到线程同步的效果,如下源码所示
SynchronizedMap(Map&amp;lt;K,V&amp;gt; m) { if (m==null) throw new NullPointerException(); this.m = m; mutex = this; } SynchronizedMap(Map&amp;lt;K,V&amp;gt; m, Object mutex) { this.m = m; this.mutex = mutex; } public int size() { synchronized(mutex) {return m.size();} } public boolean isEmpty(){ synchronized(mutex) {return m.isEmpty();} } public boolean containsKey(Object key) { synchronized(mutex) {return m.containsKey(key);} }  3.使用方式：  Map&amp;lt;String,Long&amp;gt; user = Collections.synchronizedMap(new HashMap&amp;lt;&amp;gt;()); user.put(&amp;#34;xsj&amp;#34;,1234567l); System.</description>
    </item>
    
    <item>
      <title>两个链表的第一个公共节点</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description> 题目描述：输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
解题思路：采用双指针的方式遍历链表
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) { if(pHead1 == null || pHead2 == null)return null; ListNode p1 = pHead1; ListNode p2 = pHead2; while(p1 != p2){ p1 = p1.next; p2 = p2.next; if(p1 != p2){ if(p1 == null)p1 = pHead1; if(p2 == null)p2 = pHead2; } } return p1; }  </description>
    </item>
    
    <item>
      <title>二维数组中由1构成的最大正方形</title>
      <link>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%94%B11%E6%9E%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%94%B11%E6%9E%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</guid>
      <description>题目描述：给定一个由0和1组成的2维矩阵，返回该矩阵中最大的由1组成的正方形的面积
 示例1  输入：[[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]
返回值：4
本体知识点：动态规划
 1.初步分析如下  1.确定dp[][]数组的含义 此题的dp[i][j]，代表以坐标为(i,j)的元素为右下角的正方形的边长。
2.状态转移方程 dp[i][j]的值取决于dp[i-1][j],dp[i-1][j-1],dp[i][j-1]的最小值 即左方正方形的边长，左上方正方形的边长，上方正方形的边长三者的最小值。
3.边界 由于状态转移方程中涉及i-1，j-1，所以i和j一定要大于0. 故dp[0][] 和 dp[][0]要首先确定。
 /** * 最大正方形 * @param matrix char字符型二维数组 * @return int整型 */ public int solve (char[][] matrix) { //判断二维数组是否有效 	if(matrix.length == 0 || matrix[0].length==0)return 0; int rows = matrix.length; int cols = matrix[0].lenght; int max; //声明数组 	int[][] dp = new int[rows][cols]; //确定边界值 	for(int i = 0;i&amp;lt;rows;i++){ if(matrix[i][0] == &amp;#39;1&amp;#39;)dp[i][0] = 1; } for(int j = 0;j&amp;lt;cols;j++){ if(matrix[0][j]==&amp;#39;1&amp;#39;)dp[0][j] = 1; } //确定中间值 	for(int i = 1; i &amp;lt; rows;i++){ for(int j = 1;j&amp;lt;cols;j++){ if(matrix[i][j]==&amp;#39;1&amp;#39;){ dp[i][j] = Math.</description>
    </item>
    
    <item>
      <title>链表求和及字符串求和</title>
      <link>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%92%8C/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%92%8C/</guid>
      <description>1.对字符串求和  题目描述： 以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。 （字符串长度不大于100000，保证字符串仅由’0’~‘9’这10种字符组成）
输入：”1”,“99” 输出：”100”
 /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 计算两个数之和 * @param s string字符串 表示第一个整数 * @param t string字符串 表示第二个整数 * @return string字符串 */ public String solve (String s, String t) { int i = s.length()-1,j = t.length()-1,carry=0; StringBuilder str = new StringBuilder(); while(i&amp;gt;=0 || j&amp;gt;=0 || carry!=0){ int x = i&amp;lt;0?0:s.charAt(i--)-&amp;#39;0&amp;#39;; int y = j&amp;lt;0?0:t.charAt(j--)-&amp;#39;0&amp;#39;; str.apend((x+y+carry)%10); carry = (x+y+carry)/10; } return str.reverse().toString(); }  2.链表的求和 3.</description>
    </item>
    
    <item>
      <title>二叉树根节点到叶子节点和为指定值的路径集问题</title>
      <link>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E9%9B%86%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E9%9B%86%E9%97%AE%E9%A2%98/</guid>
      <description>分析  寻找满足指定值的路径集转换为二叉树的前序遍历（根-左-右）
使用回朔（递归）的方式实现
 /** * * @param root TreeNode类 * @param sum int整型 * @return int整型ArrayList&amp;lt;ArrayList&amp;lt;&amp;gt;&amp;gt; */ ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; pathSum (TreeNode root, int sum) { if(root == null)return res; dsf(root,sum,0); return res; } public void dsf(TreeNode root, int sum,int count){ //设置递归终止条件 	if(root == null)return ; list.add(root.val); count += root.val; if(root.left == null &amp;amp;&amp;amp; root.right == null){ if(count == sum)res.</description>
    </item>
    
    <item>
      <title>矩阵的最小路路径</title>
      <link>https://fyzn12.github.io/post/algorithm/%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E8%B7%AF%E5%BE%84/</guid>
      <description>求解最值问题利用动态规划算法解决  题目描述：给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。
示例1：
输入：[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]
返回值：12
备注：1≤n,m≤2000
 思路分析：  求最值问题首先就是构建辅助数组dp
路径的走向只能是向右或者是向下，则可以将没有元素的对于的和求解出来构建一个新的二维表
二维表中国填写当前值与前一次值之和，取左下右上的两值的最小值与当前值求和填充表格
 /** * * @param matrix int整型二维数组 the matrix * @return int整型 */ public int minPathSum (int[][] matrix) { if(matrix==null)return 0; //构建列 	int row = matrix.length; int column = matrix[0].length; //构建列的值 	for(int i = 1;i&amp;lt;row;i++)matrix[i][0] = matrix[i-1][0]+matrix[i][0]; //构建行的值 	for(int j = 1;j&amp;lt;column;j++)matrix[0][j] = matrix[0][j-1] + matrix[0][j]; //填充中间数据 	for(int i = 1;i&amp;lt;row;i++){ for(int j=1;j&amp;lt;column;j++) matrix[i][j] = Math.</description>
    </item>
    
    <item>
      <title>二叉树的之字型层次遍历</title>
      <link>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B9%8B%E5%AD%97%E5%9E%8B%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B9%8B%E5%AD%97%E5%9E%8B%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题目描述：
  解题思路   设置一个标志位flag，当flag为true时，执行从左到右的遍历，反之则为从右到左
 将数放入到队列中，判断队列是否为空，作为树遍历的结束条件
 代码如下
   /** * * @param root TreeNode类 * @return int整型ArrayList&amp;lt;ArrayList&amp;lt;&amp;gt;&amp;gt; */ public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder (TreeNode root) { // write code here  ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt;(); if(root==null)return res; // 设置一个标志位  Boolean flag = true; Queue&amp;lt;TreeNode&amp;gt; que = new LinkedList&amp;lt;&amp;gt;(); que.offer(root); while(!que.isEmpty()){ int size = que.size(); ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i&amp;lt; size; i++){ TreeNode node = que.</description>
    </item>
    
    <item>
      <title>二进制中1的个数</title>
      <link>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>题解 1.暴力方法  分析：题目给一个有符号的整数int，求整数转化成二进制数后，1的个数。
直接根据题目的描述来提出方法一。有2个问题： 问题1: 如何从十进制数转化到二进制数？ 问题2:转化为二进制数后，如果判断有1的个数？
1.1 除2取模法。 int val; // input data int ans = 0; while (val != 0) { int tmp = val % 2; if (tmp == 1) ++ans; val /= 2; } 当然这种方法，对于大部分数据是对的，但是对于-2147483648,二进制为1000&amp;hellip;000，一共有31个0.因为计算机使用补码存储二进制数据的。对于这个数据，我们的方***输出0，实际上为1.所以这种方法不对。
1.2 二进制移位法 直接将整数看成二进制，然后采用移位的方法。
 int val; // input data int ans = 0; while (val != 0) { if (val &amp;amp; 1) ++ans; val &amp;gt;&amp;gt;= 1; }  代码中val &amp;amp; 1表示val 与 0x000&amp;hellip;0001（其中有31个0）进行 &amp;amp; 操作。 val &amp;gt;&amp;gt;= 1表示，如果val的二进制是110，则操作之后会变成011,也就是舍去最低位，然后最高位补0.</description>
    </item>
    
    <item>
      <title>字符串变形</title>
      <link>https://fyzn12.github.io/post/algorithm/%E5%AD%97%E7%AC%A6%E8%BD%AC%E7%9A%84%E5%8F%98%E5%BD%A2/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E5%AD%97%E7%AC%A6%E8%BD%AC%E7%9A%84%E5%8F%98%E5%BD%A2/</guid>
      <description>1. 解决此题的关键是如何将大小写字符转换 1.1 判断 字符是a-z 或者 A-Z是关键  每一个字符都有一个对应的ASII码，因此可以利用这一点来做
 1.2 大小写转换  将字符串从小写转换为大写可以如下表达：
ch[j] = (char)(ch[j]-&amp;lsquo;a&amp;rsquo;+&amp;lsquo;A&amp;rsquo;);
将字符串从大写转换为小写可以如下表达：
ch[j] = (char)(ch[j] -&amp;lsquo;A&amp;rsquo;+&amp;lsquo;a&amp;rsquo;);
题目描述如下
  public String trans(String s, int n) { // write code here  String[] str = s.split(&amp;#34; &amp;#34;,-1); StringBuilder res = new StringBuilder(); for(int i = str.length-1;i&amp;gt;=0;i--){ String tmp = str[i]; char[] ch = tmp.toCharArray(); for(int j = 0;j&amp;lt;ch.length;j++){ if(ch[j]&amp;gt;=&amp;#39;a&amp;#39; &amp;amp;&amp;amp; ch[j]&amp;lt;=&amp;#39;z&amp;#39;) ch[j] = (char)(ch[j]-&amp;#39;a&amp;#39;+&amp;#39;A&amp;#39;); else if(ch[j] &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; ch[j]&amp;lt;=&amp;#39;Z&amp;#39;) ch[j] = (char)(ch[j] -&amp;#39;A&amp;#39;+&amp;#39;a&amp;#39;); } res.</description>
    </item>
    
    <item>
      <title>二分法使用无符号位右移运算求解上中位数</title>
      <link>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E8%8E%B7%E5%8F%96/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E8%8E%B7%E5%8F%96/</guid>
      <description>获取中间值的方式一般是 int mid = left + (right-left)/2; 如果要求偶数时中位数取后一位时，需要将（right-left+1） 效率更高如下： int mid = left + ((right-left)&amp;gt;&amp;gt;1);
 1.有符号右移 &amp;gt;&amp;gt;  有符号右移：右移之后，左边补上符号为，正数补0，负数补1.
 2.无符号位右移 &amp;gt;&amp;gt;&amp;gt;  无符号右移： 右移之后， 无论该数是正数还是负数， 右移之后左边都是补上0。
 3.左移 &amp;lt;&amp;lt;  左移不区分有符号和无符号， 都是左移之后右边补上0， 最左边的符号位也直接移走。
 4.计算除法时（2的n次方）可以使用有符号的右移  20 的二进制位 10100 有符号位右移2位后为 101 十进制解释表示为 20&amp;frasl;4=5（取整）
20 的二进制位 10100 左移2位后 1010000 十进制结果为81
 5.判奇数偶数的方法  (num &amp;amp; 1) == 0表示为偶数 (num &amp;amp; 1) == 1表示为奇数
 这里注意一个遇到的坑 使用 int mid = left + ((right-left)&amp;gt;&amp;gt;1); 时切记+号后面是加一个整体，因此需要将((right-left)&amp;gt;&amp;gt;1)括起来。 6.</description>
    </item>
    
    <item>
      <title>二叉树的镜像问题</title>
      <link>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E5%8F%89%E6%95%B0%E7%9A%84%E9%95%9C%E5%83%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E4%BA%8C%E5%8F%89%E6%95%B0%E7%9A%84%E9%95%9C%E5%83%8F%E9%97%AE%E9%A2%98/</guid>
      <description>题目描述如下图所示：

解题思路：利用栈的先进后出特性去做；也可以利用队列去做，只要保证right先进队列就行
 import java.util.*; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public void Mirror(TreeNode root) { if(root==null)return; Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;TreeNode&amp;gt;(); stack.push(root); while(!stack.isEmpty()){ TreeNode tn = stack.pop(); if(tn.left != null||tn.right != null){ TreeNode temp = tn.left; tn.left = tn.right; tn.right = temp; } if(tn.</description>
    </item>
    
    <item>
      <title>扑克牌问题</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/</guid>
      <description>题目描述：LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)&amp;hellip;他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子&amp;hellip;..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。
输入：[0,3,2,6,4]
输出：true
解题思路：
我们分两种情况考虑， 一. 如果vector中不包含0的情况： 那么如何判断呢？因为需要是顺子，所以首先不能有重复值， 如果没有重复值，那么形如[1 2 3 4 5] [5 6 7 8 9]， 会发现最大值与最小值的差值应该小于5.
二. 如果数组中包含0： 发现除去0后的值，判断方法和1中是一样的。
所以根据如上两个条件，算法过程如下： 1. 初始化一个set，最大值max_ = 0, 最小值min_ = 14 2. 遍历数组， 对于大于0的整数，没有在set中出现，则加入到set中，同时更新max, min 3. 如果出现在了set中，直接返回false 4. 数组遍历完，最后再判断一下最大值与最小值的差值是否小于5
 方法1 使用set集合，利用set集合不可重复特性解决问题 public boolean isContinuous(int [] numbers) { if(numbers==null || numbers.length==0) return false; Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); int max = 0,min = 14; for(int num:numbers){ if(num&amp;gt;0){ if(set.</description>
    </item>
    
    <item>
      <title>旋转数组的问题</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98/</guid>
      <description>1.数组一次旋转的问题  题目描述：
  1.1 题目分析  处于递增：low上移
 处于递减：high下移（如果是high-1，则可能会错过最小值，因为找的就是最小值）
 其余情况：low++缩小范围
   1.2 根据算法分析，编写程序实现如下 public int minNumberInRotateArray(int [] array) { int left = 0,right = array.length-1,mid; while(left&amp;lt;right){ mid = left + ((right-left)&amp;gt;&amp;gt;1); if(array[mid]&amp;gt;array[right]){ left = mid+1; }else{ right = mid; } } return array[right]; }  2. 数组变换找目标值的问题  题目描述：给出一个转动过的有序数组，你事先不知道该数组转动了多少 (例如,0 1 2 4 5 6 7可能变为4 5 6 7 0 1 2). 在数组中搜索给出的目标值，如果能在数组中找到，返回它的索引，否则返回-1。 假设数组中不存在重复项。</description>
    </item>
    
    <item>
      <title>在无序数组中找出最小的正整数</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E6%89%BE%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B4%E6%95%B0%E5%80%BC/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E6%89%BE%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B4%E6%95%B0%E5%80%BC/</guid>
      <description> /** * return the min number * @param arr int整型一维数组 the array * @return int整型 */ public int minNumberdisappered (int[] arr) { // write code here  Arrays.sort(arr); int min = 1; for(int i = 0;i&amp;lt;arr.length;i++){ if(arr[i]==min) min++; } return min; } </description>
    </item>
    
    <item>
      <title>基于Arrays.binarySearch解决最长递增子序列</title>
      <link>https://fyzn12.github.io/post/algorithm/%E5%9F%BA%E4%BA%8Earrays.binarysearch%E8%A7%A3%E5%86%B3%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E5%9F%BA%E4%BA%8Earrays.binarysearch%E8%A7%A3%E5%86%B3%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>1. Arrays.binarySearch的简单介绍  Arrays.binarySearch构造函数的简单介绍
 1.1 binarySearch(Object[] arr, Object key)  binarySearch(Object[] arr, Object key)
arr:要检索的数组
key:要搜索的值
如果key在数组中，则返回索引值的索引；否则返回-1或者&amp;rdquo;-&amp;ldquo;(插入点)。插入点是索引键将要插入数组的哪一点，即第一个大于该键的元素的索引。
 1.1.1 技巧  [1] 搜索值不是数组元素，且在数组范围内，从1开始计数，得“ - 插入点索引值”；
[2] 搜索值是数组元素，从0开始计数，得搜索值的索引值；
[3] 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1);
[4] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1。
 1.1.2 代码  int arrays [] =new int[]{1,3,4,5,8,9};
Arrays.sort(arr);
int a = Arrays.binarySearch(arrays,6);
int b = Arrays.binarySearch(arrays,4);
int c = Arrays.binarySearch(arrays,0);
int d = Arrays.binarySearch(arrays,10);
System.out.println(&amp;ldquo;a = &amp;ldquo;+a +&amp;rdquo;,b = &amp;ldquo; +b +&amp;rdquo;,c = &amp;ldquo; + c +&amp;rdquo;,d = &amp;ldquo;+d);</description>
    </item>
    
    <item>
      <title>字符串</title>
      <link>https://fyzn12.github.io/post/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>最经典的就是寻找最长回文子串的问题
解题思想：回文子串的详细思路 在上面的链接中，对该问题做了很详细的思路讲解 下面自己实现采用 Manacher 算法，被中国程序员戏称为“马拉车”算法。它专门用于解决“最长回文子串”问题，时间复杂度为O(N) 。
 public int getLongestPalindrome(String A, int n) { // 做字符串的预处理  String str = changeStr(A,&amp;#39;#&amp;#39;); // 定义左跳跃的指针和右跳跃的指针以及最长回文串的返回值  int left=0,right=0,max=0; for(int i = 1;i&amp;lt;str.length();i++) { //判断每一步扩散的步数  right = i + 1; left = i - 1; int count = 0; while (left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; str.length() &amp;amp;&amp;amp; str.charAt(left) == str.charAt(right)) { count++; left--; right++; } max = max &amp;gt; count ?</description>
    </item>
    
    <item>
      <title>对数组中寄偶数据的处理</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%95%B4%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E5%A5%87%E5%81%B6%E6%95%B0%E6%8E%92%E5%88%97/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%95%B4%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E5%A5%87%E5%81%B6%E6%95%B0%E6%8E%92%E5%88%97/</guid>
      <description>类型一：给定一个整形数组，将数组中的数据按奇数排列在前，偶数排列在后
解题思路：定义两个指针，从前后开始遍历数组，遇到前后奇偶位置不匹配的，将其交换位置
 public void changeArr(int[] arr) { if (arr == null || arr.length == 0) { return; } int left = 0, right = arr.length - 1; while (left &amp;lt; right) { while ((arr[left] &amp;amp; 1) == 1 &amp;amp;&amp;amp; left &amp;lt; right) { left++; } while ((arr[right] &amp;amp; 1) == 0 &amp;amp;&amp;amp; left &amp;lt; right) { right--; } if (left &amp;lt; right) { arr[left] ^= arr[right]; arr[right] ^= arr[left]; arr[left] ^= arr[right]; } } }   类型二：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E7%BB%84/</guid>
      <description>总结与数组有关的算法题：
数组的概念：占据一块连续的内存，并按照顺序存储数组。
算法题： 在一个二维数组中，每一行都按照从左右到右顺序排序，每一列从上到下都按照顺序排序。给定一个数，若存在于数组中则返回true
 public static Boolean checkNum(int[][] arr,int target){ int row = 0; int column = arr[0].length-1; while (row&amp;lt;arr.length &amp;amp;&amp;amp; column &amp;gt;=0){ if (arr[row][column]==target){ return true; } if (arr[row][column]&amp;gt;target){ column--; }else { row++; } } return false; }  1.判断一个数是奇数还是偶数的方法  使用除2取余的方式 如 4%2 判断余数是否为0，是则为偶数，不是则为奇数 将判断的数与1做按位与运算，结果为1则为奇数，为0则为偶数
  2.交换两个数字的位置  使用第三变量 如 int tmp = a; a = b;b = tmp; 使用异或运算 如 a ^= b; b ^= a; a ^= b;这样既可将两个数字交换位置</description>
    </item>
    
    <item>
      <title>最长子序列问题解决思路</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>对于最长子序列以及最长子串的问题可以看这一下这位博主的博客，介绍比较详细。
最长子串及最长子序列的问题讲解
题目描述如下图所示；
   根据动态规划的思想，将问题划分为多个子问题，寻找辅助数组dp
 分析关键步骤  这里将辅助数组设为int[][] dp = new int[s1.length+1][s2.length+1];这里对于二维数组来说，多了一行一列； 在辅助数组中填入数据时，保证数组中的值永远是s1与s2响对应的最大值，这里用了原值填充，在代码中填充的字符对于的ASII码；如下图所示    dp数组中填充的值如下图所示

 在dp数组想要找到最大子序列，即可以从对角线开始找，因为一个矩阵中最长的直线在对角线；
 设计初始程序如下
public String LCS (String s1, String s2) { // write code here  if(s1==null || s1.length()==0 || s2==null || s2.length()==0)return &amp;#34;-1&amp;#34;; int s1L = s1.length(); int s2L = s2.length(); int[][] dp = new int[s1L+1][s2L+1]; StringBuilder str = new StringBuilder(); //初始化二维表的元素,  for(int i=0;i&amp;lt;s1L+1;i++){ for(int j = 0;j&amp;lt;s2L+1;j++){ //保证二维表的第一个元素为空，或者是0；  if (i==0 || j==0){ dp[i][j]=0; continue; } if(s1.</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8/</guid>
      <description>题目：输入一个链表，反转链表后，输出新链表的表头。
 1 分析  假如链表的初始化状态如下图所示：    要将链表反转，只需要将链表中的指针反转，第一个链表的指针指向为 null的链表即可
 定义三个指针 p1,p2,p3 其中p1执行为null的链表，p2，指向第一个链表，p3指向第2个链表；如下图所示；
   4. 下面需要将p2指针指向p1   将p3的指针指向p2，依次执行，知道执行到最后一个链表即可
  2. 代码实现如下图所示 public ListNode ReverseList(ListNode head) { if(head==null) return null; ListNode p1 = null; ListNode p2 = head; ListNode p3 = head.next; while(p2 != null){ p2.next = p1; p1 = p2; p2 = p3; if(p3 != null ){ p3 = p3.next; } } return p1; }   判断一个链表是否有环</description>
    </item>
    
    <item>
      <title>常见算法的实现</title>
      <link>https://fyzn12.github.io/post/faceword/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/faceword/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>问题描述：
给定一个数组arr，返回arr的最长无的重复子串的长度(无重复指的是所有数字都不相同)。
例如： 输入：[2,3,4,5] 输出：4 输入：[2,2,3,4,3] 输出：3
   public int maxLength (int[] arr) { // write code here  Map&amp;lt;Integer,Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(); if(arr==null || arr.length==0) return 0; if(arr.length==1)return 1; int left = 0,right = 0,max=0; for(int tmp = 0;right&amp;lt;arr.length;right++){ int cur = arr[right]; if(map.containsKey(cur) &amp;amp;&amp;amp; map.get(cur) &amp;gt;= left){ tmp = right-left; left = map.get(cur)+1; } if(max==0 &amp;amp;&amp;amp; tmp == 0 &amp;amp;&amp;amp; (right+1)== arr.length){ // 解决数组从第一个到最后一个都是不一样的数据长度问题  max = right-left+1; } map.</description>
    </item>
    
    <item>
      <title>mysql基础底层</title>
      <link>https://fyzn12.github.io/post/database/mysql/</link>
      <pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/database/mysql/</guid>
      <description>MYSQL的一些基础底层
 1. 数据库应用的分类  一类是OLTP：在线事务处理，如博客、电子商务、网络游戏；
另一类OLAP：在线分析处理，如数据仓库、数据集市； 对于OLAP的应用，分区的确可以很好的提高查询的性能；
 2. MYSQL的慢查询  通过 long_query_time 设置阈值，默认是10，代表10秒； 默认情况下，mysql并不启动慢查询日志，需要手工设置 log_slow_queries设置为ON开启慢查询日志。
 3. InnoDB存储引擎表类型  在InnoDB存储引擎表中，每张表都有一个主键，如果在创建表时没有显示地定义主键，则InnoDB存储引擎会按如下的方式选择创建主键。
  寻找加了unique约束并且不为NULL的列设为主键。
 如果没有，把row_id作为主键
 InnoDB在每行记录都添加了三个隐藏字段
 DB_ROW_ID &amp;mdash;6个字节：行的标识；
 DB_TRX_ID &amp;mdash;6个字节：新增更新行的最后一个事务ID，自动递增（创建版本号，数据库的乐观锁相似）； DB_ROLL_PTR &amp;mdash;7个字节：回滚指针（删除版本号）
    4. MYSQL分区 1. 分区类型  range（范围） list（离散、不连续） hash（散列） key 子分区 &amp;ndash;在分区的基础上进行分区  关键字 subpartitions
 子分区数量必须相同
  columns分区
  2. 创建方式 create table `table_name`( a int,b int )engin=innodb partition by key(b) partition 4;  另外在MYSQL数据库中还支持一种称为linear hash的分区，他使用一个更加复杂的算法来确定新行插入已经分区表中的位置。 create table `table_name`( a int,b int; )engin=innodb partition by linear hash(b) partition 4; ---指定分区数    linear hash 的优点在于，增加、删除，合并和拆分将变得更加快捷，有利于处理含有大量数据的表；</description>
    </item>
    
    <item>
      <title>SpringBoot结合antd组件Upload实现文件上传</title>
      <link>https://fyzn12.github.io/post/spring-boot/upload/</link>
      <pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/upload/</guid>
      <description>项目实现的背景介绍，当后台采用Spring Security验证信息，用户登录token保存在header中
用户每次请求需要携带对应的header和用户角色的情况时，记录一下问题
前后端分离，后台使用SpringBoot 前端采用antd pro react
 一、 后端编写业务代码过程中遇到的错误点 1. 配置SpringBoot文件上传 ## ******************************* 配置文件上传 *********************************** # 是否启用SpringMVC多分部上传功能 spring.servlet.multipart.enabled=true # 将文件写入磁盘的阀值。值可以使用后缀“MB”或“KB”来表示兆字节或字节大小 spring.servlet.multipart.file-size-threshold=0 # 指定默认上传的文件夹 # spring.servlet.multipart.location=/upload # 限制单个文件最大大小 spring.servlet.multipart.max-file-size=1MB # 限制所有文件最大大小 spring.servlet.multipart.max-request-size=10MB # 是否延迟多部件文件请求的参数和文件的解析 spring.servlet.multipart.resolve-lazily=false ## *********************** 配置静态资源文件 读取静态文件的依赖 *************************************** spring.resources.static-locations=classpath:/static/ # 以jar包发布项目时，我们存储的路径是与jar包同级的static目录，因此我们需要在jar包目录的 # application.properties配置文件中设置静态资源路径，如下所示： # 设置静态资源路径，多个以逗号分隔 # spring.resources.static-locations=classpath:static/,file:static/ spring.mvc.static-path-pattern=/static/**   上面简单的配置实现了springboot上传文件的配置，避免了SpringMVC复杂的xml文件的配置
 以jar包发布项目时，我们存储的路径是与jar包同级的static目录，因此我们需要在jar包目录的application.properties配置文件中设置静态资源路径，如下所示：设置静态资源路径，多个以逗号分隔 spring.resources.static-locations=classpath:static/,file:static/   2. 后端采用SpringMVC的MultipartFile接受前端发过来的参数 @PostMapping(&amp;#34;/modification-avatar&amp;#34;) public Map&amp;lt;String, Object&amp;gt; update(@RequestParam(value = &amp;#34;file&amp;#34;,required = false) MultipartFile file, HttpServletRequest request) throws FileNotFoundException { User user = getUserUtils.</description>
    </item>
    
    <item>
      <title>求两个有序数组的中位数</title>
      <link>https://fyzn12.github.io/post/algorithm/%E5%AF%BB%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E5%AF%BB%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>  给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
 leetcode给出从时间复杂度和空间复杂度最优解分析 方法一：二分查找 给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：
使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。 不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数 组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 000 的位置，每次将指向较小 值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数 的位置。 假设两个有序数组的长度分别为 m 和 n，上述两种思路的复杂度如何？
第一种思路的时间复杂度是 O(m+n)，空间复杂度是 O(m+n)。第二种思路虽然可以将空间复杂度降到 O(1)，但是时间复杂度仍是 O(m+n)。题目要求时间复杂度是 O(log⁡(m+n))，因此上述两种思路都不满足题目要求的时间复杂度。
如何把时间复杂度降低到 O(log⁡(m+n)) 呢？如果对时间复杂度的要求有 log，通常都需要用到二分查找，这道题也可以通过二分查找实现。
根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1。
注意：以上分析思路来自于leetcode官方阶梯思路 </description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://fyzn12.github.io/post/algorithm/tree/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/tree/</guid>
      <description>二叉树的简单介绍
 二叉树的定义 二叉树是(n&amp;gt;=0)个节点的有限集合，他或者(n==0)时为空树，或者（n&amp;gt;0时）由一个根节点及两颗互不相交的分别称为跟的左子树和右子树的二叉树组成。
2 二叉树的遍历 2.1 前序遍历 递归实现的算法分析 前序遍历二叉树的递归定义为：若二叉树为空树则遍历结束，否则
1. 访问根节点
2. 前序遍历根节点的左子树
3. 前序遍历根节点的右子树
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 算法实现 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
public class Tree { private class Bitree&amp;lt;T&amp;gt;{ T data; Bitree lchild; Bitree rchild; public Bitree(T data,Bitree lchild,Bitree rchild){ this.data = data; this.lchild = lchild; this.rchild = rchild; } } private void preorder(Bitree bt){ //设置递归终止条件  if (bt==null){ return; } //输出 跟节点  System.out.println(bt.data); //前序遍历左子树  preorder(bt.lchild); //前序遍历右子树  preorder(bt.rchild); } }  2.</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://fyzn12.github.io/post/design_mode/command-design/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/command-design/</guid>
      <description>  命令模式的简单介绍
 1 命令模式的介绍 1.1 命令模式的结构 </description>
    </item>
    
    <item>
      <title>哈希检索</title>
      <link>https://fyzn12.github.io/post/algorithm/hashtable/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/hashtable/</guid>
      <description>哈希检索算法的深度学习
 1 相关概念的理解 1.1 哈希检索  概念： 哈希检索技术的初衷是组织理想状态的检索表。检索表的理想状态是：把记录的关键字值与记录在检索表中的存储位置建立起某种一对一的关系，这种一对一的关系可以用关键字的一个函数h(key)来表示，这样不必进行关键字与给定值的比较，而是直接依据给定的关键字值来直接计算得到记录在检索表中的存储地址。 哈希函数（散列函数、杂凑函数）：反应关键字与存储位置一对一关系的函数h(key) 哈希检索技术必须解决的两个问题
（1）如何选择一个计算简单且地址冲突尽可能少的哈希函数；
（2）在出现地址冲突时采用什么办法解决冲突
  1.2 哈希函数的构建方法  直接定址法：h(key) = a*key + b 数字分析法：提前知道关键字值的集合，分析关键字集合的分布情况，确定散列函数； 平方取中法：先求出关键字的平方，然后取中间几位作为哈希地址；
 折叠法 除留余数法：h(key) = key % p 余取整法 随机数法：h(key) = random(key)
  2 地址冲突的消解策略 2.1 开放地址法 把哈希表中的空位置向处理地址冲突开放，具体的做法是，当发生地址冲突时，从发生地址冲突的那个位置开始，使用某种方法在哈希表中形成一个探查序列。
2.1.1 线性探查法  线性探查法是开放地址法消除地址冲突的一种最简单的探查方法。他把表长为m的哈希表看成是循环表，若发生地址冲突的位置地址为d，则依次探查d+1, d+2, &amp;hellip;,直到找到一个空闲位置为止。
 公式：（地址）d = (h(key)+i)%m ， 其中i=1,2,&amp;hellip;,m-1
 缺点：线性探查法易造成堆积现象。
  2.1.2 平方探查法  平方探查法也称为二次探查法。在发生地址冲突时，依次探查位置d+i，其中i取 1^2,-1^2,2^2,-2^2,&amp;hellip;, 公式：d = (h(key)+i^2)%m,d = (h(key)-i^2)%m 和中心扩展法相同，以地址冲突的位置，分别向两边去寻找空地址。</description>
    </item>
    
    <item>
      <title>LinkedList以及栈的深度理解</title>
      <link>https://fyzn12.github.io/post/algorithm/linkedlist/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/linkedlist/</guid>
      <description>算法背景:给定一个只包括 &amp;lsquo;(&amp;lsquo;，&amp;rsquo;)&amp;lsquo;，&amp;rsquo;{&amp;lsquo;，&amp;rsquo;}&amp;lsquo;，&amp;rsquo;[&amp;lsquo;，&amp;rsquo;]&amp;rsquo; 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。
 1 首先了解LinkedList的底层实现 1.1 LinkedList的底层实现 LinkedList的底层是基于 双向链表 实现，使用Node存储链表节点信息。源码如下 private static class Node&amp;lt;E&amp;gt; { E item; Node&amp;lt;E&amp;gt; next; Node&amp;lt;E&amp;gt; prev; } 每个链表都存储了first和last指针； transient Node&amp;lt;E&amp;gt; first; transient Node&amp;lt;E&amp;gt; last;   2 设计算法，实现上面的需求 2.1 算法的实现 public static boolean isValid(String s) { int n = s.length(); if (n % 2 == 1) { return false; } Map&amp;lt;Character, Character&amp;gt; pairs = new HashMap&amp;lt;Character, Character&amp;gt;() {{ put(&amp;#39;)&amp;#39;, &amp;#39;(&amp;#39;); put(&amp;#39;]&amp;#39;, &amp;#39;[&amp;#39;); put(&amp;#39;}&amp;#39;, &amp;#39;{&amp;#39;); }}; Deque&amp;lt;Character&amp;gt; stack = new LinkedList&amp;lt;Character&amp;gt;(); for (int i = 0; i &amp;lt; n; i++) { char ch = s.</description>
    </item>
    
    <item>
      <title>xml字符编码规范</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/xml%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/xml%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
      <description> xml字符编码规范
 &amp;lt; &amp;lt;(小于) &amp;gt; &amp;gt;(大于) &amp;amp; &amp;amp;(和) &amp;apos; &amp;lsquo;(单引号) &amp;quot; &amp;ldquo;(双引号)   </description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://fyzn12.github.io/post/design_mode/singleton/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/singleton/</guid>
      <description>单例模式的介绍
 1 单例模式的原理 确保一个类最多只有一个实例，并提供一个全局的访问点  2 单例模式的创建方式 2.1 饱汉模式（懒汉模式） public class SingleTon{ private SingleTon(){} //实例化放在静态代码块里，可提高程序的执行效率，但也可能更占空间 	private final static SingleTon instance = new SingleTon(); //公共结果，获取对象的实例 	public static SingleTon getInstance(){ return instance; } }  饱汉模式的优点和缺点  优点： 在多线程的情况下，可以保证SingleTon的对象唯一 缺点：在多实例或者有其他静态方法时，在启动时没有使用它的时候就已经加载好了,浪费内存。
  2.2 饥汉模式 public class SingleTon{ private SingleTon(){} private static SingleTon instance = null; public static synchronized SingleTon getInstance(){ if(instance == null){ instance = new SingleTon(); } return instance; } }  饥汉模式的优点和缺点  优点：饥汉模式解决了对象没被使用但却分配了内存空间的问题</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://fyzn12.github.io/post/design_mode/factory-pattern/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/factory-pattern/</guid>
      <description>  工厂模式的简单介绍
 1 简单的工厂模式  原理：定义一个工厂类，根据不同的参数，创建并返回不同的类。其中这些类具有一个公共的父类或是一个接口。  </description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://fyzn12.github.io/post/design_mode/decorator_design/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/decorator_design/</guid>
      <description>  装饰者模式的简单实现
 1 装饰者模式的原理  原理：动态的将新功能添加到对象上。在对象扩展方面，他比继承更具有弹性。
 别人写了一篇易懂的文章装饰者模式
  </description>
    </item>
    
    <item>
      <title>SpringBoot整合Redis使用注解实现同步缓存</title>
      <link>https://fyzn12.github.io/post/springboot%E6%95%B4%E5%90%88redis%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%BC%93%E5%AD%98/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springboot%E6%95%B4%E5%90%88redis%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%BC%93%E5%AD%98/</guid>
      <description>1 SpringBoot整合Redis的环境配置 1.1 添加依赖 &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;druid.version&amp;gt;1.1.9&amp;lt;/druid.version&amp;gt; &amp;lt;!-- mybatis的版本 --&amp;gt; &amp;lt;mybatis.version&amp;gt;3.4.6&amp;lt;/mybatis.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- 配置web启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 配置mybatis--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.15&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 配置数据库连接池 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${druid.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;!--不依赖Redis的异步客户端lettuce--&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;io.lettuce&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lettuce-core&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://fyzn12.github.io/post/design_mode/observer/</link>
      <pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/observer/</guid>
      <description> 1 观察者模式 观察者模式（又被称为发布-订阅模式），属于行为模式的一种，他定义了一种一对多得依赖关系， 让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象， 使他们能够自动更新自己   观察者主要包括以下四个部分   Subject：抽象主题，他把所有观察者对象保存在一个集合里，可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。意思就是明星把所有的粉丝都保存在一个账号里面，粉丝数量不限，可以新增粉丝也可以拉黑粉丝。
 ConcreteSubject：具体主题，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。意思是我们的明星一有动态，就会把消息给粉丝。
 Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。这就是我们所有粉丝的抽象。
 ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。具体每一个粉丝。
  </description>
    </item>
    
    <item>
      <title>数据库的事务</title>
      <link>https://fyzn12.github.io/post/database/transaction/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/database/transaction/</guid>
      <description>1. 数据库的事务 1.1 什么是事务 作为单个逻辑工作单位的一系列操作，要么完全成功，要么完全失败。  1.2 事务的四大特征ACID  A Atomic(原子性)
事务中包含的操作被看作一个整体的业务单元，这样业务单元要么完全成功，要么完全失败。最小的单元  C Consistency(一致性)
事务在完成时，必须使所有的数据都保持一致状态，在数据库中所有的修改都基于事务，保证了数据的完整性  I Isolation(隔离性)
下面将会重点讲解隔离  D Durability(持久性)
事务结束后，所有的数据会固化到一个地方，如保存到磁盘中，即使断电后也可以提供给相应程序访问   1.3 事务的隔离级别  1.3.1 读未提交造成的脏读 是最低的隔离级别，其含义是允许一个事务读取另外一个事务没有提交的数据。未提交读是一种危险 的隔离级别，所以一般在我们实际的开发中应用不广，但是它的优点在于并发能力高，适合那些对数据 一致性没有要求而追求高并发的场景，它的最大坏处是出现脏读。让我们看看可能发生的脏读场景， 如表所示。   T3时刻，因为采用未提交读，所以事务2可以读取事务l未提交的库存数据为1,这里当它扣减 库存后则数据为0，然后它提交了事务，库存就变为了。，而事务l在TS时刻回滚事 务，因为第一类丢失更新已经被克服，所以它不会将库存回滚到2，那么最后的结果就变为了 0，这样就出现了错误。脏读一般是比较危险的隔离级别，在我们实际应用中采用得不多。 为了克服脏读的问题，数据库隔离级别还提供了读已提交（readcommited）的级别， 下面我们时论它。  1.3.2 读已提交 读已提交解决了读未提交造成的脏读问题，但读已提交依然造成了另外一个问题&amp;ndash;不可重复读 读已提交： 是指一个事务只能读取另外一个事务已经提交的数据，不能读取未提交的数据。   在T3时刻事务2读取库存的时候，因为事务l未提交事务，所以读出的库存为l，于是事务2 认为当前可扣减库存；在T4时刻，事务l己经提交事务，所以在TS时刻，它扣减库存的时候 就发现库存为0，于是就无法扣减库存了。这里的问题在于事务2之前认为可以扣减，而到扣 减那一步却发现已经不可以扣减，于是库存对于事务2而言是一个可变化的值，这样的现象 我们称为不可重复读，这就是读写提交的一个不足。为了克服这个不足，数据库的隔离级别 还提出了可重复读的隔离级别，它能够消除不可重读的问题。  1.3.3 可重复读  可以看到，事务2在T3时刻尝试读取库存，但是此时这个库存己经被事务1事先读取，所以这 个时候数据库就阻塞它的读取，直至事务1提交，事务2才能读取库存的值。此时己经是TS时 刻，而读取到的值为0，这时就已经无法扣减了，显然在读写提交中出现的不可重复读的场 景被消除了。但是这样也会引发新的问题的出现，这就是幻读。  下面演示造成幻读的实战  1.3.4 序列化 (串行化) 串行化（Serializable):是数据库最高的隔离级别，它会要求所有的SQL都会按照顺序执 行，这样就可以克服上述隔离级别出现的各种问题，所以它能够完全保证数据的一致性。 2.</description>
    </item>
    
    <item>
      <title>SpringBoot优点</title>
      <link>https://fyzn12.github.io/post/spring-boot/springboot-information/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/springboot-information/</guid>
      <description> 1. SpringBoot简介 1.1 SpringBoot的优点  创建独立的Spring应用程序
 嵌入Tomcat、Jetty或者Undertow，无序部署WAR文件
 允许通过Maven来根据需要获取starter； 尽可能自动部署Spring； 提供生产就绪功能，如指标、健康检查和外部配置； 绝对没有代码生成，对XMl没有要求配置。
  1.2 传统SpringMVC和SpringBoot的对比 1.2.1 SpringMVC的工作原理  1.2.2 两者的对比 在传统的SpringMVC项目开发中，开发一个简易的SpringMVC项目，需要配置DispatcherServlet, 也需要配置SpringIoC的容器。你可以选择使用web.xml的配置来实现，当然，如果你使用的是 Servlet 3.1规范，也可以继承由SpringMVC提供的 AbstractAnnotationConfigDispatcherServletlnitializer来配置SpringMVC项目。 </description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://fyzn12.github.io/post/design_mode/strategypattern/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/design_mode/strategypattern/</guid>
      <description>1 OO設計原則 OO設計的五大原則  单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。
 开放封闭原则：实现开放封闭的核心思想就是对抽象编程，而不是对具体编程，因为抽象相对稳定。
 依赖倒置原则：依赖抽象，不要依赖具体。 里氏代换原则：子类型必须能够替换到他们的父类型。主要着眼于对抽象和多态简历在继承的基础上
 接口隔离原则：多个和客户相关的接口要好于一个通用接口
  2 设计模式————策略模式 2.1 策略模式原理 分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里放具体设定行为对象。 原则就是：分离变化部分，封装接口，基于接口编程实现各种功能。此模式让行为算法的变化独立于算法的使用者。 2.2 策略模式设计的代码分析————模拟鸭子项目 2.2.1 抽象出鸭子的行为，鸭子具有飞行能力和叫声，抽象出该接口 package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:42 * @description:会飞的鸭子 */ public interface FlyBehavior { void fly(); } package com.fyzn12.api; /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/2 10:43 * @description:叫声 */ public interface QuackBehavior { void quack(); } 2.</description>
    </item>
    
    <item>
      <title>SpringCloud微服务网关技术Zuul</title>
      <link>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zuul%E7%BD%91%E5%85%B3/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zuul%E7%BD%91%E5%85%B3/</guid>
      <description>1 网关的简介 1.1 网关API（接口） Gateway（网关） 网关的概念：相当于客户端请求统一请求到网关服务器上，再由网关服务器进行转发请求到实际的服务器地址上， 类似于Nginx。 网关的作用：网关可以拦截客户端所有请求，对该请求进行权限控制、负载均衡、日志管理、接口调用监控等 网关和过滤器的区别：过滤器适合于单个tomcat服务器进行拦截请求，网关是拦截整个微服务所有请求。 网关分为内网网关和外网网关 Nginx和Zuul网关的区别： 1. Zuul和Nginx都可以实现负载均衡、反向代理、过滤请求、实现网关效果 2. 不同点 （1）Nginx采用C语言编写，Zuul采用java语言编写，Zuul的负载均衡实现是采用Ribbon + eureka实现本地负载均衡 （2）Nginx负载均衡实现采用服务器端实现负载均衡 （3）Nginx比Zuul功能更加强大，因为Nginx整合一些脚本语言（Nginx + Lua） （4）Nginx适合于服务器端负载均衡 （5）Zuul适合服务中实现网关，而且使用技术是java 最好建议nginx + zuul实现网关 nginx作用实现反向代理 zuul对微服务实现网关拦截  1.2 接口在什么背景下产生的 在面向服务架构和微服务背景下差生，目的是为了解耦。  1.3 接口分类  开放接口&amp;mdash;&amp;ndash;其他机构合作伙伴进行调用（必须在外网访问），如微信公众号开发，需要通过appid + appsocket 生成accessToken 进行通信。对接支付宝开发、微信开发；目的可以授权，遵循OAuth2.0协议方式
 内部接口
一般只能在局域网中进行访问，服务调用之间关系都在同一个微服务系统中 目的：保证安全问题   1.3.1 设计一套项目接口需要考虑的点 接口权限（开放接口|内部接口） 考虑幂等性 安全性（https）防止串改数据（验证签名） 使用网关拦截 接口实现黑名单和白名单、接口使用http协议 + json格式，符合restful风格，目的是为了跨平台。 考虑高并发对接口服务实现保护服务降级、熔断、隔离之类 最后使用统一的API管理平台  2 搭建一个Zuul网关系统 2.1 zuul网关搭建示意图  2.2 创建zuul网关项目，在parent中添加一下依赖 &amp;lt;!-- 导入springcloud整合zuul启动器 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>SpringCloud整合Zookeeper注册中心</title>
      <link>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid>
      <description>前言 
1 使用Zookeeper代替Eureka作为注册中心 1.1 Zookeeper简介 Zookeeper分布式协调工具，可以实现注册中心 Zookeeper节点类型：临时节点 1.3 Zookeeper安装与使用 1.3.1 windows下载Zookeeper 1. 下载与安装 博客详解（别人博客）
2. 修改zkServer.cmd配置文件  3. 下载Zookeeper的图形界面的管理工具ZooInspector工具，解压之后便可使用 4. 进入Zookeeper解压之后的目录，直到bin目录，在该目录输入cmd进入控制台  5. 在控制台运行zkServer.cmd便可开启Zookeeper服务  2 使用Zookeeper作为注册中心步骤 zookeeper作为注册中心与Eureka作为注册中心的区别在于Eureka需要编写一个服务的启动类，但Zookeeper不需要 Zookeeper只需要打开ZooInspector工具，连接服务即可（确保在cmd中运行zkServer.cmd）  2.1 创建会员服务 2.1.1 配置pom文件 &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.fyzn12&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springcloud-zk-member&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;springcloud-zk-member Maven Webapp&amp;lt;/name&amp;gt; &amp;lt;!-- FIXME change it to the project&amp;#39;s website --&amp;gt; &amp;lt;url&amp;gt;http://www.example.com&amp;lt;/url&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Hoxton.SR2&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>java基础底层</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</guid>
      <description>1 JVM的解析 1.1 JVM的结构图  大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区） ,Heap（堆） , Program Counter Register （程序计数器） , VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,Native Method Stack （ 本地方法栈 ） ，其中Method Area 和 Heap 是线程共享的 ，VM Stack，Native Method Stack 和Program Counter Register 是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。 首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件 （以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字 节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ 概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程， 就为其分配一个 Program Counter Register（程序计数器） , VM Stack（虚拟机栈）和Native Method Stack （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放 掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相 同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域 （实际上对大部分虚拟机来说知发生在Heap上）的原因。 1.</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>java多线程总结 多线程的几种实现方式  继承Thread类 重写run（）方法定义线程的行为；
如下图所示  实现Runnable接口
如下图所示
    实现 Callable 接口，该接口中的 call方法可以在线程执行结束时产生一个返回值。
使用总结：因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类就无法再继承其 他类了，显然使用 Runnable 接口更为灵活。
实现Runnable接口比继承Thread类所具有的优势：
1）：适合多个相同的程序代码的线程去处理同一个资源 2）：可以避免java中的单继承的限制 3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类 创建多线程的三种方式:两个接口（Runnable、Callable）一个类（Thread）  实例变量与线程安全 自定义线程类中的实例变量针对其他线程可以有共享与不共享之分。当每个线程都有各自的实例变量时，就是变量不共享。共享数据的情况就是多个线程可以访问同一个变量。 来看下面的示例：  打印的结果中存在多个线程同时对count进行操作，产生了&amp;#34;非线程安全&amp;#34;问题 * 在某些JVM中，i--的操作要分成如下3步： * 取得原有变量的值。计算i-1。对i进行赋值。 * 在这三个步骤中，如果有多个线程同时访问，那么一定会出现非线程安全问题。 解决方法就是使用 synchronized 同步关键字 使各个线程排队执行run()方法。修改后的run()方法：    synchronized 关键字的用法 在上面提到&amp;#34;同步&amp;#34;关键字，synchronized关键字可以将方法或者对象标记为同步，以实现对对象和法 的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将 synchronized 作为方法的修饰符。 如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另 一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数 据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方 法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效 率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。  线程的状态变化 要想实现多线程，必须在主线程中创建新的线程对象。任何线程一般具有5种状态，即创建，就绪，运行 阻塞，终止。下面分别介绍一下这几种状态：  创建状态</description>
    </item>
    
    <item>
      <title>Spring Boot整合Spring Data JPA</title>
      <link>https://fyzn12.github.io/post/spring-boot/spring-data/</link>
      <pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/spring-data/</guid>
      <description>Spring Boot整合Spring Data JPA 1 Spring Boot整合Spring Data JPA环境的搭建和测试 1.1 创建项目配置pom文件  Spring Boot整合Spring Data JPA时需要添加一下依赖包
&amp;lt;dependencies&amp;gt; &amp;lt;!-- 导入springboot的启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 导入mybatis的启动器 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 导入springboot整合spring Data JPA的启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- mysql数据库 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- mysql的连接池 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${druid.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 
 该项目需要有一个父工程，该工程打包方式以pom形式打包，整合了测试所需要的的依赖包。
  1.2 创建application.properties文件 注意：该文件这里主要配置数据库的连接，Jpa的一些属性  配置数据库的连接； 配置正向工程和sql语句的显示。</description>
    </item>
    
    <item>
      <title>redis之java客户端</title>
      <link>https://fyzn12.github.io/post/redis/jedis/</link>
      <pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/redis/jedis/</guid>
      <description>1 jedis的简单介绍 1.1 Jedis是什么 直观来说，jedis就是redis-cli   1.2 引入jedis的依赖包 &amp;lt;!-- 引入jedis的依赖包 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.3&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  1.3 jedis直连  生成一个Jedis对象，这个对象负责和指定Redis节点进行通信
Jedis jedis = new Jedis(&amp;ldquo;127.0.0.1&amp;rdquo;,6379);
 jedis执行set操作
jedis.set(&amp;ldquo;hello&amp;rdquo;,&amp;ldquo;world&amp;rdquo;);
 jedis执行get操作，value=&amp;ldquo;world&amp;rdquo;
String value = jedis.get(&amp;ldquo;hello&amp;rdquo;);
   Jedis构造函数的简单介绍 Jedis构造方法的参数 Jedis(String host,int port,int connectionTimeout,int soTimeout); host:Redis节点的所在机器的IP； port：Redis节点的端口； connectionTimeout：客户端连接超时； soTimeout：客户端读写超时；  1.4 Jedis直连和连接池的对比  2 redis的具体实现 2.1 慢查询  生命周期
 三个命令
 两个配置
 运维经验
  2.</description>
    </item>
    
    <item>
      <title>数据库易忘知识点总结</title>
      <link>https://fyzn12.github.io/post/database/database/</link>
      <pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/database/database/</guid>
      <description>数据库的基本知识点
 1 数据库的基本常用知识点 1.1 在创建数据库时，指定数据库编码命令 create database ads character set &amp;#39;utf8&amp;#39; 如图所示   1.2 对数据表的操作  删除数据
语法：
delete from 表名 [where 条件]
注意：
* 如果不加条件，则删除表中所有记录。
* 如果要删除所有记录
delete from 表名&amp;mdash;不推荐使用。有多少条记录就会执行多少次删除操作。
* TRUNCATE TABLE 表名；&amp;ndash;推荐使用，效率更高，先删除表，然后创建相同的表。
 update 表名 set 列名1 = 值1，列名2 = 值2，&amp;hellip;[where 条件]; 注意：如果不加条件，则会修改所有的记录；
 多表查询取出重复的行
关键字 distinct  DQL：查询语句
 排序查询
语法：order by 子句
排序方式： ASC：升序；DESC：降序
注意：如果有多个排序条件，则当前的条件值一样时，才会判断第二个条件。
 聚合函数：
（1）count：计算个数
（2）max
（3）min
（4）sum</description>
    </item>
    
    <item>
      <title>数据库易忘知识点总结</title>
      <link>https://fyzn12.github.io/post/database/%E5%AF%BC%E5%87%BA%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/database/%E5%AF%BC%E5%87%BA%E7%BB%93%E6%9E%84/</guid>
      <description>根据数据表，导出数据结构
 SELECT COLUMN_NAME 列名, COLUMN_TYPE 数据类型, DATA_TYPE 字段类型, CHARACTER_MAXIMUM_LENGTH 长度, IS_NULLABLE 是否为空, COLUMN_DEFAULT 默认值, COLUMN_COMMENT 备注 FROM INFORMATION_SCHEMA. COLUMNS WHERE &amp;ndash; super_express为数据库名称，到时候只需要修改成你要导出表结构的数据库即可 table_schema = &amp;lsquo;super_express&amp;rsquo; AND &amp;ndash; s_patient_list为表名，到时候换成你要导出的表的名称 &amp;ndash; 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称 table_name = &amp;lsquo;user&amp;rsquo;</description>
    </item>
    
    <item>
      <title>SpringCloud整合Hystrix服务保护框架</title>
      <link>https://fyzn12.github.io/post/springcloud/hystrix%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/hystrix%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E6%A1%86%E6%9E%B6/</guid>
      <description>1 引入Hystrix需要了解的知识点 1.1 服务的雪崩效应 服务的雪崩效应：默认情况下，tomcat只有一个线程池去处理所有客户端发生的所有请求，这样在高并发下的情况下， 如果客户端所有的请求堆积到同一个接口上（也就是客户端访问同一个接口），tomcat的所有线程去处理请求，可能 会导致其他服务接口无法访问。 假设tomcat最大请求数为20，客户端发送的请求数为100，会发生80个请求产生延迟等待  1.2 Hystrix服务保护框架能解决什么问题  断路器
 服务降级
 服务熔断
 服务隔离机制
 服务雪崩效应，连环雪崩效应
注意：如果雪崩效应严重的话，可能会造成整个服务崩溃   1.3 Hystrix解决雪崩效应的原理  服务降级 &amp;mdash;-友好提示
在高并发的情况下，防止用户一直等待，在tomcat中没有线程处理客户端发生的请求时，不应该让客户端一直在等待， 使用服务降级（返回一个友好的提示给客户端），目的是为了用户的体验，调用fallback本地方法  服务隔离 &amp;mdash;-线程池隔离和信号量隔离
信号量的使用示意图：当n个并发请求去调用一个目标服务接口时，都要获取一个信号量才能真正去调用 目标服务接口，但信号量有限，默认是10个，可以使用maxConcurrentRequests参数配置，如果并发请求数多于 信号量个数，就有线程需要进入队列排队，但排队队列也有上限，默认是 5，如果排队队列也满，则必定有请求线 程会走fallback流程，从而达到限流和防止雪崩的目的。 信号量模式从始至终都只有请求线程自身，是同步调用模式，不支持超时调用，不支持直接熔断，由于没有线程的 切换，开销非常小。 线程池的使用示意图如下图所示，当n个请求线程并发对某个接口请求调用时，会先从hystrix管理的线程池里面 获得一个线程，然后将参数传递给这个线程去执行真正调用。线程池的大小有限，默认是10个线程，可以使用 maxConcurrentRequests参数配置，如果并发请求数多于线程池线程个数，就有线程需要进入队列排队，但排队 队列也有上限，默认是 5，如果排队队列也满，则必定有请求线程会走fallback流程。 线程池模式可以支持异步调用，支持超时调用，支持直接熔断，存在线程切换，开销大。    服务熔断
服务熔断目的是为了保护服务，在高并发的情况下，如果请求达到一定得极限（可以设置阈值），如果流量超过 了这是的阈值，自动开启保护服务的功能，使用服务降级方式返回一个友好的提示。服务熔断和服务降级一起使用  2 搭建Hystrix服务保护框架 2.1 feign客户端超时设置 首先了解feign客户端默认超时时间是1秒 ribbon: # 建立连接所用的时间 ReadTimeout: 5000 # 建立之后读取所用的时间 ConnectTimeout: 5000  2.</description>
    </item>
    
    <item>
      <title>微服务架构的介绍</title>
      <link>https://fyzn12.github.io/post/springcloud/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 26 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</guid>
      <description>微服务架构的介绍 1 单体架构 单体架构也称为单体系统或者单体应用。就是一种把系统中的所有功能、模块耦合在一个应用中的架构方式  1.1 单体架构特点 1. 单体架构最终会打包成一个独立的单元(导成一个唯一的jar包或者war包) 2. 会以一个进程的方式来运行 3. 项目结构图如下图所示  
1.2 单体架构的优点、缺点 1.2.1 优点： 1. 项目易于管理 2. 部署简单  1.2.2 缺点： 1. 测试成本高 2. 可伸缩性差 3. 可靠性差 4. 迭代困难 5. 跨语言程度差 6. 团队协作难  2 微服务架构 2.1 什么是微服务 微服务就是一种架构风格，一个大型的复杂软件应用，由一个或多个微服务组成。 系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅仅关注于完成一件任务。  2.2 什么架构风格 架构风格就是项目的一种设计模式  2.2.1 常见的架构风格  客户端与服务端
 基于组件模型的架构（EJB） 分层架构（MVC） 面向服务架构（SOA）
  2.3 微服务的特点 1. 系统是由多个服务构成 2. 每个服务可以单独独立部署 3. 每个服务之间是松耦合的。服务内部是高内聚的，外部是低耦合的。高内聚就是每个服务只关注于完成一个功能  2.</description>
    </item>
    
    <item>
      <title>SpringCloud之Eureka2.0服务注册中心</title>
      <link>https://fyzn12.github.io/post/springcloud/springcloud-eureka/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/springcloud-eureka/</guid>
      <description>SpringCloud之Eureka2.0服务注册中心 1 了解相关概念 1.1 微服务架构如何拆分  微服务架构把每一个职责单一功能存放在独立的服务中
 每个服务运行在单独的进程中
 每个服务有自己独立数据库存储、实际上有自己独立的缓存、数据库、消息队列等
  1.2 微服务架构与SOA架构区别  微服务架构基于SOA架构演变过来，继承SOA架构优点，在微服务架构中去除SOA架构中的ESB消息总线，采用http+json（restful）进行传输。
 微服务架构比SOA架构粒度会更加精细，让专业的人去做专业的事。
 SOA架构中可能数据存储会发生共享，微服务架构强调每个服务都是单独的数据库，保证每个服务与服务之间互不影响。
  1.3 一线简单的概念 1.3.1 服务治理 服务治理： 阿里巴巴开源的Dubbo和当当网在基础上扩展的Dubbox，Eureka，Apache的Consul等 1.3.2 服务注册与发现 RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）  服务注册与服务发现原理，在任何的RPC远程调用框架中，都会有一个注册中心。
 注册中心的概念：存放服务地址相关信息（接口地址） SpringCloud中支持一下三种注册中心
Eureka Consul（go语言编写） Zookerper 注意：Dubbo支持两种Redis和Zookeeper     springcloud组件架构图

  2 SpringCloud支持的三种注册中心详解 2.1 Eureka注册中心环境搭建 2.1.1 配置基于单集群的环境 1. 配置pom文件 &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.fyzn12&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springcloud-study-server&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;springcloud-study-server Maven Webapp&amp;lt;/name&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>SpringCloud整合Consul注册中心</title>
      <link>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88consul%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/springcloud/springcloud%E6%95%B4%E5%90%88consul%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid>
      <description>SpringCloud整合Consul注册中心 1 Consul简介 Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更“一站式”，内置了服务注册与发现框 架、具有以下性质： 分布一致性协议实现、 健康检查、 Key/Value存储、 多数据中心方案， 不再需要依赖其他工具（比如ZooKeeper等）。 2 SpringCloud整合Consul 2.1 创建会员服务 2.1.1 配置会员服务的pom文件 &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.fyzn12&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springcloud-consul-member&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;springcloud-consul-member Maven Webapp&amp;lt;/name&amp;gt; &amp;lt;!-- FIXME change it to the project&amp;#39;s website --&amp;gt; &amp;lt;url&amp;gt;http://www.example.com&amp;lt;/url&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Hoxton.SR2&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- 导入springboot的启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 导入springcloud整合Zookeeper启动器--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>java基础篇</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/</guid>
      <description>JVM加载class文件的原理机制 JVM中类的装载是由类加载器（ClassLoader）和他的子类来实现的，java中的类加载器是一个重要的 java运行时系统组件，他负责在运行时查找和装入类文件中的类。 JDK和JRE的区别 * JDK ：java development kit的简称，java开发的环境和运行环境 * JRE ：java runtime environment的简称，java运行环境。 * 具体来说JDK其实包含了jre，如下图所示  同时还包含了编译java远吗的编译器javac，还包含了很多java调试和分析的工具。
==和equals的区别 ==解读 对于基本类型和引用类型 == 的作用效果是不同的， * 基本类型：比较的是值是否相等 ； * 引用类型：比较的是引用是否相同； 如下代码 String x = &amp;#34;string&amp;#34;; String y = &amp;#34;string&amp;#34;; System.out.println(x==y); // true System.out.println(x==z); // false System.out.println(x.equals(y)); // true System.out.println(x.equals(z)); // true 因为x和y指向的是同一个“引用”，所以 == 是true，换句话说： == 是对引用类型作比较。 而new String（）方法则重新开辟了内存空间，所以 == 比较的是两个不同的引用，== 比较的结果则为false。 而equals比较的是 “值” ，所以结果都为true。  equals解读 equals的本质就是 ==，只不过String和Integer等重写了equals的方法，把他变成了 &amp;#34; 值 的 比 较 &amp;#34; equals的源码如下 public boolean equals（Object obj）{ return (this == obj); } 在没有重写equals方法时 equals就是==，他们比较的都是引用类型是否相等，而不是值是否相等； 如下代码可以很清晰的解释这一观点： class Cat { public Cat(String name) { this.</description>
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/jvm/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/jvm/</guid>
      <description>jvm初学篇
 1 JVM的启动流程  通过编辑器将java代码编辑好之后编译成java字节码，也就是.class文件；
 装载JVM 会通过当前路径或者系统的版本去寻找 JVM.cfg文件； 通过JVM.cfg文件寻找到 JVM.dll文件 &amp;mdash;该文件是JVM的具体实现；
 初始化本地接口 JNI &amp;mdash;如Env接口 JNI接口的作用就是负责将.class文件装载到JVM中；
 找到main方法并执行
   2 JVM的内存分区  1 PC寄存器  &amp;mdash; 每个线程拥有一个PC寄存器
 &amp;mdash; 在线程创建时 创建（PC寄存器）
 &amp;mdash; 指向下一条指令的地址
 &amp;mdash; 执行本地方法时，PC的值为undefined（未定义）  2 方法区  &amp;mdash; 保存装载的类信息
 类型的常量池 &amp;mdash;&amp;ndash; 这一点得注意 ： 在JDK6时，String等常量信息是保存在方法区，但是在JDK7时，已经移到了堆； 字段、方法信息
 方法字节码
  &amp;mdash; 线程共享
 &amp;mdash; 通常和永久区（Perm：保存一些相对来说静止稳定的数据）关联在一起
  3 Java堆  &amp;mdash; 和程序开发密切相关</description>
    </item>
    
    <item>
      <title>JVM初始化初步理解</title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/jvm%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/jvm%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</guid>
      <description>要了解JVM首先得了解JVM如何创建，然后深入JVM的内存分析
首先java程序在执行时会被编译成java字节码即.class文件————&amp;gt;其次加载配置文件 jvm.cfg（会根据系统的版本去寻找该配置文件）
————&amp;gt;根据加载后的配置文件找到 jvm.dll文件，该文件是 jvm 的主要实现 ————&amp;gt; 初始化java本地接口JNI接口
————&amp;gt; 找到main方法，执行程序
 注意JNI的作用：当一个程序被编译成java字节码之后是保存在硬盘中，而JVM是如何从硬盘中找到该.class文件， JNI接口的作用就是将该.class文件装载到JVM中，然后才能找到main方法执行程序，所以JNI接口的作用 非常重要。 进而是如何装载.class文件的下面继续详细介绍  JVM 的思维导图如下图所示
 &amp;lt;/div</description>
    </item>
    
    <item>
      <title>redis基础知识</title>
      <link>https://fyzn12.github.io/post/redis/redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/redis/redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <description>1 Redis的简介 1.1 了解什么是redis redis是一个开源的使用ANSI c语言编写、遵循BSA协议、支持网络、可基于内存亦可持久化的日志型、key-value数据库， 并提供多种语言的API。 他通常被称为数据结构服务器，因为值value可以是String、哈希（hash）、列表（list）、集合（sets）、和有序集合（sorted sets）等类型。  1.2 redis的特点 * Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 * Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 * Redis支持数据的备份，即master-slave模式的数据备份。  1.3 redis的优势 * 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 * 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 * 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务， 即原子性，通过MULTI和EXEC指令包起来。 * 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。  1.4 Redis支持的数据类型 * string（字符串） * hash（哈希） * list（列表） * set（集合） * zset或sorted set（有序集合）  2 Redis 命令 2.</description>
    </item>
    
    <item>
      <title>几种结构</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>  数据结构的分析
 1 队列 队列采用先进先出策略的集合类型，如图所示
1.1 队列的入队演示 如图将 89 添加到队列中，采用的是 ： 在队列队尾添加，整个事件时间复杂度为O(1)  1.2 队列的出队演示 当队列收到出队的命令后，会将指针指向head，从而移除head的值，原先head值指向的下一个值变为head，整个事件时间复杂度为 O(1)  注意：java中还有先进先出队列，策略和基本队列相反，和下面的栈的策略相同 1.3 队列的总结，队列是采用先进先出的策略，添加元素时是在队尾添加，出队时是在队头移除或出队 2 链表 2.1 链表插入策略的演示 2.1.1 头插  2.1.2 尾插  2.1.3 中间任意部位插入 任意部位的插入首先要指定一个插入点，在插入过程中会先遍历插入点前面的元素，找到插入点元素 之后在修改插入点元素的指针，让其指向新增元素   3 栈 栈（stack）是操作受限的线性表，限定元素的插入和删除运算只能在表的一端进行，通常把进行插入删除的一端称作栈顶（top） 另一端称为栈底（bottom）  3.1 栈的五种运算  置空栈setnull（s）：将栈s设置成空栈，即不管栈的原来状态如何一律置为空栈；
 判断栈是否为空empty(s):返回一个布尔值，当栈为空时返回1，否则返回返回0；
 进栈push(s,x):把元素x压入栈s中，成为新的栈顶元素；
 出栈pop(s):该操作从栈顶弹出栈顶元素并返回，栈为空时返回NULL；
 读栈顶元素gettop(s):返回栈顶元素，该操作栈的状态不变；   栈与队列的总结 栈可以形象的比喻为一个瓶子，先进的元素只能从瓶口进，然后往瓶底走，出的时候也只能从瓶口出，而后面进的元素往往先出 队列可以看成一条管道，该管道从bottom入，top出 </description>
    </item>
    
    <item>
      <title>常见算法篇</title>
      <link>https://fyzn12.github.io/post/algorithm/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
      <description>常见算法总结篇 递归算法 递归算法有一下几个特点 * 递归算法必须设定循环终止条件，称为递归出口 * 方法里调用自身 如下面两个例子： 1. 一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。 例：n=1237 函数设定如下： //编写递归函数 private static void getNUm(int n){ //设置递归终止条件 System.out.printl(n); if（n&amp;lt;=5000）{ //调用自身 getNum(n*2); System.out.printl(n); } } 2. 第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？ 程序设定如下 //n代表传入的人的数量 private static int getAge(int n){ //设定递归终止条件 if（n==1） return 10; //调用自身并返回； return getAge(n-1)+2; } 排序算法  快速排序算法 排序步骤总结如下：
* 从数组中挑出一个元素，称为“基准”（pivot）； * 重新排序数组，所有元素比基准值小的摆放在基准前面，所有元素比基准大的摆放在基准的后面 （相同可以任意放一边）。这个分割之后，该基准就是他的最后的位置，这个称为“分割”操作 * 递归地把小于基准值元素的子数组和大于基准元素的子数组排序。 下面看一个列子： 请用快速排序排序下面的数组内的数字：String[] strVoid=new String[]{&amp;#34;11&amp;#34;,&amp;#34;66&amp;#34;,&amp;#34;22&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;55&amp;#34;,&amp;#34;22&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;32&amp;#34;}; 代码设计如下：严格按照上面三个步骤设计 //三个参数，排序的数组，排序左基点，排序右基点 private static void quickSort(String[] strViod,int left,int right){ //先判断左右指针是否越界 if (left&amp;gt;right){ returen; } //定义基准位置，左右移动时的指针以及中间变量 String standard,tmp; //步骤一：确定基准位置（可以随意） standard = strViod[left]; int i,j; i = left; j = right; //步骤二：初步与基准值比较，确认基准值的左右集合 while(i&amp;lt;j){ //首先进行基准值右侧值的判断,这里建议将String转为int进行判断，别用compareTo进行判断 while(Integer.</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://fyzn12.github.io/post/algorithm/selectionsorted/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/selectionsorted/</guid>
      <description>排序算法的简单介绍
 1 选择排序 1.1 选择排序的理解 选择排序（Selection sort）是一种简单直观的排序算法。 它的工作原理是： 第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置， 然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序 的数据元素的个数为零。选择排序是不稳定的排序方法。  1.2 选择排序的实现 /** * @author ZhangRongJun * @version 1.0 * @date 2020/9/14 18:41 * @description:选择排序 */ public class SelectionSort { public static void sort(Comparable[] a) { int N = a.length; //将a[]按升序排序  for (int i = 0; i &amp;lt; N; i++) { int min = i; for (int j = i+1;j&amp;lt;N;j++){ if (less(a[j],a[min])){ min = j; } } exch(a,i,min); } } private static boolean less(Comparable v,Comparable w){ return v.</description>
    </item>
    
    <item>
      <title>认真刷面试题的第一天</title>
      <link>https://fyzn12.github.io/post/faceword/firstday/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/faceword/firstday/</guid>
      <description>牛客网的第一天
 1 关于java的异常处理机制：当某个线程抛出OutOfmemberError时，其他线程有可能不收影响 2 关于运算的理解  与运算（&amp;amp;）
进行运算的两个数据，按二进制位进行“与”运算。 规则：0&amp;amp;0=0; 0&amp;amp;1=0; 1&amp;amp;0=0; 1&amp;amp;1=1; 即： 两位同时为“1”，结果才为“1”，否则为0  或运算（|）
进行运算的两个数据，按二进制位进行“或”运算。 运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1； 即 ：参加运算的两个对象只要有一个为1，其值为1。  非运算：~
1取0，0取1 ~1 = 0, ~0 = 1 ~(10001) = 01110  异或运算（^）
参加运算的两个数据，按二进制位进行&amp;#34;异或&amp;#34;运算 参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 考点：交换两个变量的值（不借助第三个变量） 使用异或运算符： 例：a=6,b=5 核心代码： a = a ^ b; b = a ^ b; a = a ^ b;   经过上面的介绍下面这些运算应该就能理解了java中的 |= 、&amp;amp;= 、^= 运算符的理解
3 filesort 并不是磁盘文件进行排序，只是进行了一个排序操作，但是查询次数过多确实会对性能造成影响 4 在java中是不能强制垃圾回收器立即执行的，system.</description>
    </item>
    
    <item>
      <title>SpringBoot提供的五种异常机制</title>
      <link>https://fyzn12.github.io/post/spring-boot/springboot-exception/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/spring-boot/springboot-exception/</guid>
      <description>SpringBoot中的异常处理方式  自定义错误页面
 @ExceptionHandle注解处理异常
 @ControllerAdvice + @ExceptionHandle注解处理异常
 配置SimpleMappingExceptionResolver处理异常
 自定义HandleExceptionResolver类处理异常
  1 自定义错误页面 1.1 SpringBoot的默认异常机制详解 SpringBoot默认的异常机制：SpringBoot默认已经提供了一套处理异常的机制。 一旦程序中出现了异常，SpringBoot会向/error的url发送请求。在SpringBoot中提供了一个 叫BasicExceptionController来处理/error请求，然后跳转到默认显示的页面来展示异常信息。   1.2 自定义错误界面 如果我们需要将所有的异常统一跳转到自定义错误页面，需要在classpath下创建一个templates目录(即在resources目录下创建templates目录)，在该目录下创建一个名为error.html的页面。 2 基于@ExceptionHandler注解处理异常 2.1 创建指定处理的异常 /** *java.lang.ArithmeticException *该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 *参数Exceptione:会将产生异常对象注入到方法中 */ @ExceptionHandler(value={java.lang.ArithmeticException.class}) publicModelAndViewarithmeticExceptionHandler(Exceptione){ ModelAndViewmv=newModelAndView(); mv.addObject(&amp;#34;error&amp;#34;,e.toString()); mv.setViewName(&amp;#34;error1&amp;#34;); returnmv; } /** *java.lang.NullPointerException *该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 *参数Exceptione:会将产生异常对象注入到方法中 **/ @ExceptionHandler(value={java.lang.NullPointerException.class}) publicModelAndViewnullPointerExceptionHandler(Exceptione){ ModelAndViewmv=newModelAndView(); mv.addObject(&amp;#34;error&amp;#34;,e.toString()); mv.setViewName(&amp;#34;error2&amp;#34;); return mv； }  2.2 使用该方法的总结 使用@ExceptionHandler注解处理异常时，首先编写异常页面error.html，其次创建Controller类，编写基于注解@ExceptionHandle注解的方法，并且在该方法中必须指定想要助理异常的名称如上面的java.lang.NullPointerException.class、java.lang.ArithmeticException.class。 3 使用@ControllerAdvice + @ExceptionHandler注解处理异常 3.1 创建一个全局异常类使用ControllerAdvice注解 /** *全局异常处理类 **/ @ControllerAdvice public class GlobalException { /** * java.</description>
    </item>
    
    <item>
      <title>mybatis之动态SQL</title>
      <link>https://fyzn12.github.io/post/mybatis/dynamicsql/</link>
      <pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/mybatis/dynamicsql/</guid>
      <description>动态SQL语句总结 主要内容  if元素
 choose、when、otherwise元素 trim、where、set元素 foreach元素  if 元素 下面先看一个例子
&amp;lt;select id=&amp;#34;selectUserById&amp;#34; resultType=&amp;#34;MyUser&amp;#34; parameterType=&amp;#34;MyUser&amp;#34;&amp;gt; select * from user where 1=1 &amp;lt;if test =&amp;#34;name !=null and name !=&amp;#39;&amp;#39;&amp;#34;&amp;gt; and name like concat(&amp;#39;%&amp;#39;,#{name},&amp;#39;%&amp;#39;) &amp;lt;/if&amp;gt; &amp;lt;if test = &amp;#34;sex !=null and sex !=&amp;#39;&amp;#39;&amp;#34;&amp;gt; and sex = #{sex} &amp;lt;/if&amp;gt; &amp;lt;/select&amp;gt;  在上面的例子中，运用的是sql语句的拼接，在这里需要注意的是有如下几点：
1. resultType与resultMap不能同时使用 2. #{xxx}与${vlaue}的使用看上一篇博客 3. if的判断条件的test里面的参数目前我知道有三种声明方式如下： 1）对象作为参数，则test里面的参数为对象的属性 2)@Param声明的参数 3)map方式键值对  choose、when 、otherwise元素 有些时候不想用到所以的条件语句，而只想从中选择一二，针对这种情况，Mybatis提供了&amp;lt;choose&amp;gt;元素，如下例子。
&amp;lt;select id = &amp;#34;selectUserBychoose&amp;#34; resultType=&amp;#34;MyUser&amp;#34; parameterType=&amp;#34;MyUser&amp;#34;&amp;gt; select * from user where 1=1 &amp;lt;choose&amp;gt; &amp;lt;when test=&amp;#34;name !</description>
    </item>
    
    <item>
      <title>ssm随学札记</title>
      <link>https://fyzn12.github.io/post/ssm/ssm%E9%9A%8F%E5%AD%A6%E6%9C%AD%E8%AE%B0/</link>
      <pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/ssm/ssm%E9%9A%8F%E5%AD%A6%E6%9C%AD%E8%AE%B0/</guid>
      <description>使用在使用ObjectMapper将json转对象，调用mapper.readValue(jsonStr, XwjUser.class)时，报如下错：
java.lang.NullPointerException at com.fasterxml.jackson.core.JsonFactory.createParser(JsonFactory.java:889) at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3004) at com.express.utils.JsonUtils.jsonToPojo(JsonUtils.java:48) at com.express.web.controller.backstage.ManagerBaseController.getCurrentUser(ManagerBaseController.java:29) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.method.annotation.ModelFactory.invokeModelAttributeMethods(ModelFactory.java:142) at org.springframework.web.method.annotation.ModelFactory.initModel(ModelFactory.java:111) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:872) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942)  这个错误产生的原因有三个：
1. 是因为在使用ObjectMapper将json转为对象时，会默认调用该对象的无参构造函数，因此在该对象类中加入无参构造函数即可去掉该错误。
2. 期待转成的对象与json对应的属性不匹配。
3. 真正的空指针，既json为空。
ajax提交的几个坑  通过ajax提交数据，在后台是无法进行重定向的，只能通过前端进行重定向。具体如何实现如下：
* 判断满足需要重定向时，需要修改返回前端的Header以及Status，并设置拦截（当然这个可以不用）。
* 编写redirectUtil工具类,处理后台跳转，这里需要注意，设置 response.setStatus(HttpServletResponse.SC_FORBIDDEN);之后前端会被拦截，报403错误，代表服务端终止，前端进行操作。
/** *@author fyzn12 *@version 1.0 *@date 2020/4/18 13:46 *主要作用于ajax请求，后台重定向 *提供日志接口 *提供获取具体日志对象的方法 */ @Slf4j public class RedirecUtil { public static void redirect(HttpServletRequest request,HttpServletResponse response,String redirectUrl){ try { /* *如果是ajax请求 **/ String ajax = &amp;#34;XMLHttpRequest&amp;#34;; String header = &amp;#34;X-Requested-With&amp;#34;; if(ajax.</description>
    </item>
    
    <item>
      <title>Mybatis-的配置文件</title>
      <link>https://fyzn12.github.io/post/mybatis/mybatis01/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/mybatis/mybatis01/</guid>
      <description>Mybatis的配置文件以及mapper文件 在mybatis的配置文件中，所有的配置均是在 &amp;lt;configuration&amp;gt;&amp;lt;/configuration&amp;gt;`这对标签里配置。在这里记录一些课堂老师讲解的重要配置。  &amp;lt;configuration&amp;gt; 1.配置日志（开启日志）通过```&amp;lt;settings&amp;gt;&amp;lt;/settings&amp;gt;```标签配置，如下所示： &amp;lt;!-- 开启日志 --&amp;gt; &amp;lt;settings&amp;gt; &amp;lt;setting name=&amp;#34;logImpl&amp;#34; value=&amp;#34;LOG4J&amp;#34;/&amp;gt; &amp;lt;/settings&amp;gt; 2.为了提高效率，在mapper文件不用每个resultType属性里都添加包名，设置别名。设置在typeAliases标签里，如下两种方式配置，优点和缺点 &amp;lt;typeAliases&amp;gt; &amp;lt;typeAlia type=&amp;#34;com.pojo.Student&amp;#34;alias=&amp;#34;Student&amp;#34;/&amp;gt;--方法一 缺点：有多少个类，就得有多少行这个代码 &amp;lt;!-- 或者&amp;lt;package name=&amp;#34;com.pojo/&amp;gt;&amp;#34; --方法二 缺点： 在pojo包下如果还有子包，在子包下有与子包同级的类名相同时，会出现歧义，不知指定的是哪个包。 &amp;lt;/typeAliases&amp;gt; 3.数据库连接的配置
&amp;lt;environments default=&amp;#34;default&amp;#34;&amp;gt; &amp;lt;!--配置多个数据源,但只能指定一个使用 --&amp;gt; &amp;lt;!-- Mysql的数据库链接 --&amp;gt; &amp;lt;environment id=&amp;#34;default&amp;#34;&amp;gt; &amp;lt;transactionManager type=&amp;#34;JDBC&amp;#34;/&amp;gt;&amp;lt;!-- 指定当前数据库的事务管理方式 --&amp;gt; &amp;lt;dataSource type=&amp;#34;POOLED&amp;#34;&amp;gt;&amp;lt;!-- 数据源的管理方式为连接池 --&amp;gt; &amp;lt;property name=&amp;#34;driver&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;dbc:mysql://localhost:3306/ssmLab4046?serverTimezone=GMT%2B8&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;1234&amp;#34;/&amp;gt; &amp;lt;!-- 设定数据库的链接4要素 --&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt;  4.映射文件的扫面通过标签配置。
&amp;lt;!-- 一定是文件格式--&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;#34;com/mapper/StudentMapper.xml&amp;#34;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;mapper&amp;gt;&amp;lt;/mapper&amp;gt;  mapper文件配置以及对应方法的讲解  mapper配置时设置的属性namespace定义一个操作包，是映射文件匹配的重要点；</description>
    </item>
    
    <item>
      <title>mybatis之mapper接口编程</title>
      <link>https://fyzn12.github.io/post/mybatis/mapper%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/mybatis/mapper%E7%BC%96%E7%A8%8B/</guid>
      <description>面向接口编程的思路  创建pojo（javaBean）类
 创建接口
 创建接口对应的mapper文件
注意：
1）mapper文件名必须和接口名相同，如接口名为ITeacher则mapper名为ITeacher（并且在同一个包下，实践得到）,如果使用扫描包的方式，那么两者必须在同一个包下，如
 
  如果用读取文件的方式，则不用在同一个包下如下
&amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;#34;mapper/*.xml&amp;#34;/&amp;gt; &amp;lt;/mappers&amp;gt; 2）mapper文件的namespace取值必须和接口的全路径相同
3）mapper中的SQL声明的id必须和接口中的方法名相同，如接口中声明方法seleteAll则sql的id必须为seleteAll
4）多参传递可以不写parameterType属性
5）参数的下标书写 &amp;lt;selete * from teacher where name=#{0} and age=#{1}表示方法中传的参数的第一个参数和第二个参数
6）参数的占位书写
7）参数的声明书写 方法中用@Param声明。
4. 读取mybatis-config.xml文件获取数据库的连接，以及读取mapper文件，得到InputStream对象，创建SqlSessionFactory对象，利用SqlSessionFactory对象建立session连接通过openSession（）方法
InputStream is; try { //1.利用org.apache.ibatis.io.Resources方法读取mybatis-config.xml is = Resources.getResourceAsStream(&amp;#34;mybatis-config.xml&amp;#34;); // 2.通过文件流,创建一个sqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder() .build(is); // 3.通过工厂创建一个数据库的连接session session = factory.openSession(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } &amp;emsp;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/</guid>
      <description>1 并发的原理解析 1.1 并发会造成什么问题  死锁
 资源占用 线程安全
&amp;hellip;
  1.2 并发的根本问题  原子性
 可见性
 有序性
  以上三个是造成线程安全的主要原因
1.2.1 线程在那里创建的 线程在CPU上开启和执行
在硬件上面CPU的缓存一致性即可见性 单核CPU没有可见性 在硬件上解决缓存一致性伊利诺斯协议&amp;ndash;MESI
1.2.2 java直接跟硬件交互的是什么 java直接跟硬件交互的是JVM
关键值在反射的标识是二进制
java中8个高级指令 lock unlock &amp;hellip;.
1.2.3 volatile解决可见性的原理，当然他也解决了有序性 需要了解指令重排序，指令流 数据量 控制流
volatile解决不了原子性</description>
    </item>
    
    <item>
      <title>二维数组中由1构成的最大正方形</title>
      <link>https://fyzn12.github.io/post/algorithm/new-document/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/new-document/</guid>
      <description> </description>
    </item>
    
  </channel>
</rss>