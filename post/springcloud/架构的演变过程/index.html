<!DOCTYPE html>
<html lang="en"><head>
    <title>首页</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no" />
    <meta name="theme-color" content="#000084" />
    <link rel="icon" href="https://fyzn12.github.io/favicon.ico">
    <link rel="canonical" href="https://fyzn12.github.io">
    
    
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"></button>
            <a class="brand" href="https://fyzn12.github.io">首页</a>
            <div class="nav-collapse collapse">
                <ul class="nav">
                    
                    
                        
                            <li>
                                <a href="/about/">
                                    
                                    <span>About</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/post/">
                                    
                                    <span>All posts</span>
                                </a>
                            </li>
                        
                    
                </ul>
            </div>
        </div>
    </div>
</nav><div id="content" class="container">

<div class="row-fluid navmargin">
    <div class="page-header">
        <h1>微服务架构的介绍 - Fri, Jun 26, 2020</h1>
    </div>
    <p class="lead">微服务架构的介绍... ...</p>
    

<h1 id="微服务架构的介绍">微服务架构的介绍</h1>

<hr />

<h1 id="1-单体架构">1 单体架构</h1>

<pre><code>    单体架构也称为单体系统或者单体应用。就是一种把系统中的所有功能、模块耦合在一个应用中的架构方式  
</code></pre>

<h2 id="1-1-单体架构特点">1.1 单体架构特点</h2>

<pre><code>1. 单体架构最终会打包成一个独立的单元(导成一个唯一的jar包或者war包)  
2. 会以一个进程的方式来运行  
3. 项目结构图如下图所示  
</code></pre>

<p><div align=center><img src="https://fyzn12.github.io/img/picture/mvc.png"/></div></p>

<h2 id="1-2-单体架构的优点-缺点">1.2 单体架构的优点、缺点</h2>

<h3 id="1-2-1-优点">1.2.1 优点：</h3>

<pre><code>        1. 项目易于管理  
        2. 部署简单  
</code></pre>

<h3 id="1-2-2-缺点">1.2.2 缺点：</h3>

<pre><code>        1. 测试成本高  
        2. 可伸缩性差  
        3. 可靠性差  
        4. 迭代困难  
        5. 跨语言程度差  
        6. 团队协作难  
</code></pre>

<hr />

<h1 id="2-微服务架构">2 微服务架构</h1>

<h2 id="2-1-什么是微服务">2.1 什么是微服务</h2>

<pre><code>        微服务就是一种架构风格，一个大型的复杂软件应用，由一个或多个微服务组成。  
    系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅仅关注于完成一件任务。  
</code></pre>

<h2 id="2-2-什么架构风格">2.2 什么架构风格</h2>

<pre><code>        架构风格就是项目的一种设计模式  
</code></pre>

<h3 id="2-2-1-常见的架构风格">2.2.1 常见的架构风格</h3>

<ol>
<li>客户端与服务端<br /></li>
<li>基于组件模型的架构（EJB）</li>
<li>分层架构（MVC）</li>
<li>面向服务架构（SOA）<br />

<br /></li>
</ol>

<h2 id="2-3-微服务的特点">2.3 微服务的特点</h2>

<pre><code>1. 系统是由多个服务构成  
2. 每个服务可以单独独立部署  
3. 每个服务之间是松耦合的。服务内部是高内聚的，外部是低耦合的。高内聚就是每个服务只关注于完成一个功能  
</code></pre>

<h2 id="2-4-微服务的优点-缺点">2.4 微服务的优点、缺点</h2>

<h3 id="2-4-1-优点">2.4.1 优点</h3>

<ol>
<li>测试容易<br /></li>
<li>可伸缩性强<br /></li>
<li>可靠性强<br /></li>
<li>跨语言程度会更加灵活<br /></li>
<li>团队协作更加容易<br /></li>
<li>系统迭代容易<br /></li>
</ol>

<h3 id="2-4-2-缺点">2.4.2 缺点</h3>

<ol>
<li>运维成本过高，部署数量较多<br /></li>
<li>接口兼容多版本<br /></li>
<li>分布式系统的复杂性<br /></li>
<li>分布式事务<br /></li>
</ol>

<hr />

<h1 id="3-mvc-rpc-soa-微服务架构之间的区别">3 MVC、RPC、SOA、微服务架构之间的区别</h1>

<h2 id="3-1-mvc架构">3.1 MVC架构</h2>

<pre><code>    其实MVC架构就是一种单体架构  
    代表技术：Struts2、SpringMVC、Spring、Mybatis等等  
</code></pre>

<h2 id="3-2-rpc架构">3.2 RPC架构</h2>

<pre><code>        RPC(Remote Procedure Call)远程过程调用。他是一种通过网络从远程计算机程序上请求服务，而不需要   
        了解底层网络技术的协议。  

        代表技术：Thrift、Hessian等  
</code></pre>

<h2 id="3-3-soa架构">3.3 SOA架构</h2>

<pre><code>    SOA(Service Oriented Architecture)面向服务架构  

    ESB企业服务总线，服务中介。主要是提供一个服务与服务之间的交互。  
    ESB包含的功能：负载均衡，流量控制，加密处理，服务的监控，异常处理，监控告急等等。  

    代表技术：Mule、WSO2  
</code></pre>

<h2 id="3-4-微服务架构">3.4 微服务架构</h2>

<pre><code>    微服务架构就是一种轻量级的服务治理方案  

    代表技术：SpringCloud、Dubbo等  
</code></pre>

<h1 id="4-微服务架构的设计原则">4 微服务架构的设计原则</h1>

<p>微服务架构设计遵循以下原则</p>

<ol>
<li>AKF拆分原则（重点掌握）<br /></li>
<li>前后端分离原则<br /></li>
<li>无状态服务<br /></li>
<li>Restful的通信风格<br /></li>
</ol>

<h2 id="4-1-akf拆分原则">4.1 AKF拆分原则</h2>

<pre><code>    业界对于可扩展的系统架构设计有一个朴素的理念,就是：通过加机器就可以解决容量和可用性问题。  
    (如果一台不行那就两台)。我是个段子：（世界上没有什么事是一顿烧烤不能解决的。如果有，那就两  
    顿。）这一理念在“云计算”概念疯狂流行的今天，得到了广泛的认可！对于一个规模迅速增长的系统而  
    言，容量和性能问题当然是首当其冲的。但是随着时间的向前，系统规模的增长，除了面对性能与容量的  
    问题外，还需要面对功能与模块数量上的增长带来的系统复杂性问题以及业务的变化带来的提供差异化服  
    务问题。而许多系统，在架构设计时并未充分考虑到这些问题，导致系统的重构成为常态，从而影响业务  
    交付能力，还浪费人力财力！对此，《可扩展的艺术》一书提出了一个更加系统的可扩展模型——AKF可扩展  
    立方（ScalabilityCube）。这个立方体中沿着三个坐标轴设置分别为：X、Y、Z。  
</code></pre>

<div align=center><img src="https://fyzn12.github.io/img/picture/AKF.png"/></div>    
 

<h3 id="4-1-1-y轴-功能">4.1.1 Y轴（功能）</h3>

<pre><code>    Y轴扩展会将庞大的整体应用拆分为多个服务。每个服务实现一组相关的功能，如订单管理、客户管理等。  
    在工程上常见的方案是服务化架构(SOA)。比如对于一个电子商务平台，我们可以拆分成不同的服务，  
    组成下面这样的架构：  
</code></pre>

<div align=center><img src="https://fyzn12.github.io/img/picture/Y.png"/></div>   
  

<h4 id="总结-但通过观察上图容易发现-当服务数量增多时-服务调用关系变得复杂-为系统添加一个新功能-要调用的服务数也变得不可控-由此引发了服务管理上的混乱-所以-一般情况下-需要采用服务注册的机制形成服务网关来进行服务治理-系统的架构将变成下图所示">总结：  但通过观察上图容易发现，当服务数量增多时，服务调用关系变得复杂。为系统添加一个新功能，要调用的服务数也变得不可控，由此引发了服务管理上的混乱。所以，一般情况下，需要采用服务注册的机制形成服务网关来进行服务治理。系统的架构将变成下图所示：</h4>

<div align=center><img src="https://fyzn12.github.io/img/picture/Y-getway.png"/></div>   
  

<h3 id="4-1-2-x轴-水平扩展">4.1.2 X轴（水平扩展）</h3>

<pre><code>        X轴扩展与我们前面朴素理念是一致的，通过绝对平等地复制服务与数据，以解决容量和可用性的问题。  
    其实就是将微服务运行多个实例，做集群加负载均衡的模式。为了提升单个服务的可用性和容量，  
    对每一个服务进行X轴扩展划分。  
</code></pre>

<div align=center><img src="https://fyzn12.github.io/img/picture/X.png"/></div>    
  

<h3 id="4-1-3-z轴-数据分区">4.1.3 Z轴（数据分区）</h3>

<pre><code>    Z轴扩展通常是指基于请求者或用户独特的需求，进行系统划分，并使得划分出来的子系统是相互隔离但   
    又是完整的。以生产汽车的工厂来举例：福特公司为了发展在中国的业务，或者利用中国的廉价劳动力，  
    在中国建立一个完整的子工厂，与美国工厂一样，负责完整的汽车生产。这就是一种Z轴扩展。  
</code></pre>

<h4 id="工程领域常见的z轴扩展有以下两种方案">工程领域常见的Z轴扩展有以下两种方案：</h4>

<h5 id="1-在分布式服务设计领域-一个单元-cell-就是满足某个分区所有业务操作的自包含闭环-如上面我们说到的y轴扩展的soa架构-客户端对服务端节点的选择一般是随机的-但是-如果在此加上z轴扩展-那服务节点的选择将不再是随机的了-而是每个单元自成一体-如下图">1. 在分布式服务设计领域，一个单元（Cell）就是满足某个分区所有业务操作的自包含闭环。如上面我们说到的Y轴扩展的SOA架构，客户端对服务端节点的选择一般是随机的，但是，如果在此加上Z轴扩展，那服务节点的选择将不再是随机的了，而是每个单元自成一体。如下图：</h5>

<div align=center><img src="https://fyzn12.github.io/img/picture/Z-1.png"/></div>    
  

<h5 id="2-数据分区-为了性能数据安全上的考虑-我们将一个完整的数据集按一定的维度划分出不同的子集-一个分区-shard-就是是整体数据集的一个子集-比如用尾号来划分用户-那同样尾号的那部分用户就可以认为是一个分区-数据分区为一般包括以下几种数据划分的方式">2. 数据分区 ：为了性能数据安全上的考虑，我们将一个完整的数据集按一定的维度划分出不同的子集。一个分区（Shard），就是是整体数据集的一个子集。比如用尾号来划分用户，那同样尾号的那部分用户就可以认为是一个分区。数据分区为一般包括以下几种数据划分的方式：</h5>

<pre><code>    数据类型（如：业务类型）  
    数据范围（如：时间段，用户ID）  
    数据热度（如：用户活跃度，商品热度）  
    按读写分（如：商品描述，商品库存）  
</code></pre>

<h2 id="4-2-前后端分离原则">4.2 前后端分离原则</h2>

<pre><code>    何为前后端分离？前后端本来不就分离么？这要从尴尬的jsp讲起。分工精细化从来都是蛋糕做大的原则，  
    多个领域工程师最好在不需要接触其他领域知识的情况下合作，才可能使效率越来越高，维护也会变得简  
    单。jsp的模板技术融合了html和java代码，使得传统MVC开发中的前后端在这里如胶似漆，前端做好页  
    面，后端转成模板，发现问题再找前端，前端又看不懂java代码......前后端分离的目的就是将这尴尬  
    局面打破。前后端分离原则，简单来讲就是前端和后端的代码分离，我们推荐的模式是最好采用物理分离  
    的方式部署，进一步促使更彻底的分离。如果继续直接使用服务端模板技术，如：jsp，把java、js、  
    html、css都堆到一个页面里，稍微复杂一点的页面就无法维护了。  
</code></pre>

<h3 id="这种分离方式有几个好处">这种分离方式有几个好处：</h3>

<ol>
<li>前后端技术分离，可以由各自的专家来对各自的领域进行优化，这样前段的用户体验优化效果更好。<br /></li>
<li>分离模式下，前后端交互界面更清晰，就剩下了接口模型，后端的接口简洁明了，更容易维护。<br /></li>
<li>前端多渠道集成场景更容易实现，后端服务无需变更，采用统一的数据和模型，可以支持多个前端：例如：微信h5前端、PC前端、安卓前端、IOS前端。<br /></li>
</ol>

<h2 id="4-3-无状态服务">4.3 无状态服务</h2>

<div align=center><img src="https://fyzn12.github.io/img/picture/notType.png"/></div>  
  

<pre><code>    对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，  
    那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。  
    那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业    
    务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。场景说  
    明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数  
    据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸  
    缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。   
</code></pre>

<h2 id="4-4-restful的通讯风格">4.4 RestFul的通讯风格</h2>

<ol>
<li>无状态协议HTTP，具备先天优势，扩展能力很强。例如需要安全加密，有现成的成熟方案HTTPS即可。<br /></li>
<li>JSON报文序列化，轻量简单，人与机器均可读，学习成本低，搜索引擎友好。<br /></li>
<li>语言无关，各大热门语言都提供成熟的RestfulAPI框架，相对其他的一些RPC框架生态更完善。


<br />

<br /></li>
</ol>

    <h4><a href="https://fyzn12.github.io">Back to Home</a></h4>
</div>


        </div><footer class="container">
    <hr class="soften">
    <p>

    <a href="https://fyzn12.github.io">fyzn12</a> | 

&copy; 
<a href="https://fyzn12.github.io" target="_blank">
    fyzn12
</a>
<span id="thisyear">2020</span>

    | @


        | Built on <a href="//gohugo.io" target="_blank">Hugo</a>
</p>
    <p class="text-center">
        <a href="https://facebook.com">Facebook</a> 
        <a href="https://twitter.com">Twitter</a> 
        <a href="https://linkedin.com">Linkedin</a> 
        <a href="https://github.com">GitHub</a> 
        <a href="https://gitlab.com">GitLab</a>
    </p>
</footer>

</body><link rel="stylesheet" href="/css/bootstrap.css">
<link rel="stylesheet" href="/css/bootstrap-responsive.css">
<link rel="stylesheet" href="/css/style.css">

<script src="/js/jquery.js"></script>
<script src="/js/bootstrap-386.js"></script>
<script src="/js/bootstrap-transition.js"></script>
<script src="/js/bootstrap-alert.js"></script>
<script src="/js/bootstrap-modal.js"></script>
<script src="/js/bootstrap-dropdown.js"></script>
<script src="/js/bootstrap-scrollspy.js"></script>
<script src="/js/bootstrap-tab.js"></script>
<script src="/js/bootstrap-tooltip.js"></script>
<script src="/js/bootstrap-popover.js"></script>
<script src="/js/bootstrap-button.js"></script>
<script src="/js/bootstrap-collapse.js"></script>
<script src="/js/bootstrap-carousel.js"></script>
<script src="/js/bootstrap-typeahead.js"></script>
<script src="/js/bootstrap-affix.js"></script>
<script>
    _386 = { 
        fastLoad: false ,
        onePass: false , 
        speedFactor: 1 
    };

    
    function ThisYear() {
        document.getElementById('thisyear').innerHTML = new Date().getFullYear();
    };
</script></html>
