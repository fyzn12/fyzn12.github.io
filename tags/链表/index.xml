<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>链表 on fyzn12</title>
    <link>https://fyzn12.github.io/tags/%E9%93%BE%E8%A1%A8/</link>
    <description>Recent content in 链表 on fyzn12</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 31 Dec 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://fyzn12.github.io/tags/%E9%93%BE%E8%A1%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>链表求和及字符串求和</title>
      <link>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%92%8C/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%92%8C/</guid>
      <description>1.对字符串求和  题目描述： 以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。 （字符串长度不大于100000，保证字符串仅由’0’~‘9’这10种字符组成）
输入：”1”,“99” 输出：”100”
 /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 计算两个数之和 * @param s string字符串 表示第一个整数 * @param t string字符串 表示第二个整数 * @return string字符串 */ public String solve (String s, String t) { int i = s.length()-1,j = t.length()-1,carry=0; StringBuilder str = new StringBuilder(); while(i&amp;gt;=0 || j&amp;gt;=0 || carry!=0){ int x = i&amp;lt;0?0:s.charAt(i--)-&amp;#39;0&amp;#39;; int y = j&amp;lt;0?0:t.charAt(j--)-&amp;#39;0&amp;#39;; str.apend((x+y+carry)%10); carry = (x+y+carry)/10; } return str.reverse().toString(); }  2.链表的求和 3.</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E9%93%BE%E8%A1%A8/</guid>
      <description>题目：输入一个链表，反转链表后，输出新链表的表头。
 1 分析  假如链表的初始化状态如下图所示：    要将链表反转，只需要将链表中的指针反转，第一个链表的指针指向为 null的链表即可
 定义三个指针 p1,p2,p3 其中p1执行为null的链表，p2，指向第一个链表，p3指向第2个链表；如下图所示；
   4. 下面需要将p2指针指向p1   将p3的指针指向p2，依次执行，知道执行到最后一个链表即可
  2. 代码实现如下图所示 public ListNode ReverseList(ListNode head) { if(head==null) return null; ListNode p1 = null; ListNode p2 = head; ListNode p3 = head.next; while(p2 != null){ p2.next = p1; p1 = p2; p2 = p3; if(p3 != null ){ p3 = p3.next; } } return p1; }   判断一个链表是否有环</description>
    </item>
    
    <item>
      <title>几种结构</title>
      <link>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fyzn12.github.io/post/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>  数据结构的分析
 1 队列 队列采用先进先出策略的集合类型，如图所示
1.1 队列的入队演示 如图将 89 添加到队列中，采用的是 ： 在队列队尾添加，整个事件时间复杂度为O(1)  1.2 队列的出队演示 当队列收到出队的命令后，会将指针指向head，从而移除head的值，原先head值指向的下一个值变为head，整个事件时间复杂度为 O(1)  注意：java中还有先进先出队列，策略和基本队列相反，和下面的栈的策略相同 1.3 队列的总结，队列是采用先进先出的策略，添加元素时是在队尾添加，出队时是在队头移除或出队 2 链表 2.1 链表插入策略的演示 2.1.1 头插  2.1.2 尾插  2.1.3 中间任意部位插入 任意部位的插入首先要指定一个插入点，在插入过程中会先遍历插入点前面的元素，找到插入点元素 之后在修改插入点元素的指针，让其指向新增元素   3 栈 栈（stack）是操作受限的线性表，限定元素的插入和删除运算只能在表的一端进行，通常把进行插入删除的一端称作栈顶（top） 另一端称为栈底（bottom）  3.1 栈的五种运算  置空栈setnull（s）：将栈s设置成空栈，即不管栈的原来状态如何一律置为空栈；
 判断栈是否为空empty(s):返回一个布尔值，当栈为空时返回1，否则返回返回0；
 进栈push(s,x):把元素x压入栈s中，成为新的栈顶元素；
 出栈pop(s):该操作从栈顶弹出栈顶元素并返回，栈为空时返回NULL；
 读栈顶元素gettop(s):返回栈顶元素，该操作栈的状态不变；   栈与队列的总结 栈可以形象的比喻为一个瓶子，先进的元素只能从瓶口进，然后往瓶底走，出的时候也只能从瓶口出，而后面进的元素往往先出 队列可以看成一条管道，该管道从bottom入，top出 </description>
    </item>
    
  </channel>
</rss>